<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neural Swipe Typing - ONNX Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    <!-- Swipe Vocabulary Module -->
    <script src="swipe-vocabulary.js"></script>
    <!-- Custom Dictionary Support -->
    <script src="custom-dictionary.js"></script>
    <!-- Niche Words Loader -->
    <script src="niche-words-loader.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'dark-bg': '#0a0a0f',
                        'dark-surface': '#141420',
                        'dark-key': '#1a1a2e',
                        'dark-key-hover': '#252540',
                        'neon-blue': '#00d4ff',
                        'neon-purple': '#b300ff',
                        'neon-pink': '#ff00d4',
                    },
                    animation: {
                        'glow': 'glow 2s ease-in-out infinite',
                        'pulse-neon': 'pulse-neon 1.5s ease-in-out infinite',
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
            50% { box-shadow: 0 0 30px rgba(179, 0, 255, 0.8); }
        }
        
        @keyframes pulse-neon {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .neon-trail {
            filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 12px currentColor);
        }

        .key-active {
            background: linear-gradient(135deg, #00d4ff, #b300ff) !important;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.8), inset 0 0 20px rgba(179, 0, 255, 0.3);
            transform: scale(0.95);
        }

        .loading-spinner {
            border: 3px solid rgba(0, 212, 255, 0.1);
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .debug-overlay {
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(0, 212, 255, 0.8);
        }

        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Responsive keyboard sizing */
        @media (max-height: 600px) {
            .key {
                height: 2.5rem !important;
            }
            .main-content-padding {
                padding-bottom: 220px !important;
            }
        }
        
        @media (max-height: 500px) {
            .key {
                height: 2rem !important;
            }
            .main-content-padding {
                padding-bottom: 180px !important;
            }
        }
        
        /* Mobile keyboard optimizations */
        @media (max-width: 768px) {
            .keyboard-container {
                border-radius: 0 !important;
                padding-bottom: env(safe-area-inset-bottom);
            }
            .keyboard-container > div > div {
                border-radius: 1rem 1rem 0 0 !important;
            }
        }
        
        /* iOS safe area handling */
        @supports (padding: max(0px)) {
            .keyboard-container {
                padding-bottom: max(env(safe-area-inset-bottom), 0.5rem);
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-dark-bg via-gray-900 to-dark-bg min-h-screen max-h-screen flex flex-col overflow-hidden">
    <!-- Header -->
    <div class="bg-dark-surface/80 backdrop-blur-xl border-b border-white/10">
        <div class="p-4 text-center">
            <h1 class="text-2xl font-bold bg-gradient-to-r from-neon-blue to-neon-purple bg-clip-text text-transparent">
                Neural Swipe Typing - ONNX
            </h1>
            <p class="text-gray-400 text-sm mt-1">
                <span id="modelStatus">Loading models...</span>
            </p>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="bg-dark-surface/60 backdrop-blur px-4 py-3 flex justify-between items-center border-b border-white/5">
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <div id="statusIndicator" class="w-2 h-2 bg-gray-500 rounded-full"></div>
                <span id="statusText" class="text-gray-300 text-sm">Initializing...</span>
            </div>
            <div id="coordinateDisplay" class="text-xs text-neon-blue font-mono hidden">
                X: <span id="xCoord">0</span> Y: <span id="yCoord">0</span> | 
                Norm: <span id="normCoords">0.00, 0.00</span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="clearInput()" 
                    class="px-4 py-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 text-sm transition-all hover:border-neon-blue/50">
                Clear
            </button>
            <button onclick="toggleDebug()" 
                    class="px-4 py-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 text-sm transition-all hover:border-neon-purple/50">
                Debug: <span id="debugStatus">OFF</span>
            </button>
            <button onclick="toggleDictionary()" 
                    class="px-4 py-1.5 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 text-sm transition-all hover:border-neon-green/50">
                ðŸ“š Dictionary
            </button>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-grow flex flex-col min-h-0 overflow-hidden pb-[280px] md:pb-[240px] main-content-padding">
        <!-- Input Display -->
        <div class="bg-dark-surface/40 backdrop-blur px-4 py-2 flex-shrink-0">
            <div class="text-gray-400 text-xs uppercase tracking-wide mb-1">Input Text</div>
            <div id="inputText" class="text-white text-lg min-h-[25px] break-words"></div>
        </div>

        <!-- Word Suggestions -->
        <div id="suggestions" class="px-4 py-3 flex gap-2 flex-wrap bg-dark-surface/40 backdrop-blur flex-shrink-0 min-h-[60px]">
            <div class="text-gray-500 text-sm">Tap or swipe on the keyboard to begin</div>
        </div>

        <!-- Debug Output -->
        <div id="debugOutput" class="hidden px-4 py-2 bg-black/50 backdrop-blur flex-shrink-0 max-h-32 overflow-auto">
            <pre id="debugText" class="text-xs text-neon-blue font-mono"></pre>
        </div>
        
        <!-- Spacer -->
        <div class="flex-grow"></div>
    </div>

    <!-- Debug Overlay -->
    <div id="debugOverlay" class="absolute top-32 left-2 pointer-events-none z-20 hidden">
        <div class="text-xs text-neon-blue debug-overlay bg-black/70 p-2 rounded">
            <div>Current Key: <span id="currentKeyDebug">-</span></div>
            <div>Path Length: <span id="pathLength">0</span></div>
            <div>Keys Touched: <span id="keysTouched">-</span></div>
        </div>
    </div>

    <!-- Dictionary Panel -->
    <div id="dictionaryPanel" class="fixed inset-0 bg-black/75 backdrop-blur flex items-center justify-center z-50 hidden">
        <div class="bg-dark-surface rounded-2xl p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-white">ðŸ“š Custom Dictionary Manager</h2>
                <button onclick="toggleDictionary()" 
                        class="text-gray-400 hover:text-white transition-colors text-2xl">
                    âœ•
                </button>
            </div>
            
            <div class="flex-1 overflow-y-auto space-y-4">
                <!-- Import Section -->
                <div class="bg-white/5 rounded-lg p-4 border border-white/10">
                    <h3 class="text-lg font-semibold text-white mb-3">Import Words</h3>
                    
                    <div class="space-y-3">
                        <!-- File Upload -->
                        <div>
                            <label class="block text-sm text-gray-400 mb-2">Upload Dictionary File</label>
                            <input type="file" id="dictionaryFile" accept=".txt,.csv,.json" 
                                   class="w-full px-3 py-2 bg-white/10 rounded-lg text-gray-300 border border-white/20 hover:border-neon-blue/50 transition-colors">
                        </div>
                        
                        <!-- Text Input -->
                        <div>
                            <label class="block text-sm text-gray-400 mb-2">Or Paste Words (one per line)</label>
                            <textarea id="customWordList" rows="4" 
                                      placeholder="Enter words here..."
                                      class="w-full px-3 py-2 bg-white/10 rounded-lg text-gray-300 border border-white/20 hover:border-neon-blue/50 transition-colors resize-none"></textarea>
                        </div>
                        
                        <button onclick="importCustomWords()" 
                                class="w-full px-4 py-2 bg-neon-blue/20 hover:bg-neon-blue/30 text-neon-blue rounded-lg transition-colors">
                            Import Words
                        </button>
                    </div>
                </div>
                
                <!-- Personal Dictionary Section -->
                <div class="bg-white/5 rounded-lg p-4 border border-white/10">
                    <h3 class="text-lg font-semibold text-white mb-3">Personal Dictionary</h3>
                    
                    <div class="flex gap-2 mb-3">
                        <input type="text" id="newWord" placeholder="Add a word..." 
                               class="flex-1 px-3 py-2 bg-white/10 rounded-lg text-gray-300 border border-white/20 hover:border-neon-purple/50 transition-colors">
                        <button onclick="addPersonalWord()" 
                                class="px-4 py-2 bg-neon-purple/20 hover:bg-neon-purple/30 text-neon-purple rounded-lg transition-colors">
                            Add
                        </button>
                    </div>
                    
                    <div id="personalWordsList" class="max-h-40 overflow-y-auto space-y-1">
                        <!-- Personal words will be listed here -->
                    </div>
                </div>
                
                <!-- Statistics -->
                <div class="bg-white/5 rounded-lg p-4 border border-white/10">
                    <h3 class="text-lg font-semibold text-white mb-3">Dictionary Statistics</h3>
                    <div class="grid grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="text-gray-400">Base Dictionary:</span>
                            <span id="baseDictSize" class="text-white ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Custom Words:</span>
                            <span id="customDictSize" class="text-white ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Personal Words:</span>
                            <span id="personalDictSize" class="text-white ml-2">0</span>
                        </div>
                        <div>
                            <span class="text-gray-400">Total Words:</span>
                            <span id="totalDictSize" class="text-white ml-2">0</span>
                        </div>
                    </div>
                </div>
                
                <!-- Export/Import Buttons -->
                <div class="flex gap-2">
                    <button onclick="exportDictionary()" 
                            class="flex-1 px-4 py-2 bg-green-600/20 hover:bg-green-600/30 text-green-400 rounded-lg transition-colors">
                        Export All
                    </button>
                    <button onclick="loadNicheWords()" 
                            class="flex-1 px-4 py-2 bg-yellow-600/20 hover:bg-yellow-600/30 text-yellow-400 rounded-lg transition-colors">
                        Load Niche Words
                    </button>
                    <button onclick="clearCustomDictionary()" 
                            class="flex-1 px-4 py-2 bg-red-600/20 hover:bg-red-600/30 text-red-400 rounded-lg transition-colors">
                        Clear Custom
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black/75 backdrop-blur flex items-center justify-center z-50">
        <div class="text-center">
            <div class="loading-spinner mx-auto mb-4"></div>
            <p class="text-white">Loading ONNX models...</p>
            <p id="loadingDetails" class="text-gray-400 text-sm mt-2"></p>
        </div>
    </div>

    <!-- Keyboard Container -->
    <div class="fixed bottom-0 left-0 right-0 z-30 keyboard-container">
        <div class="w-full max-w-2xl mx-auto">
            <div class="relative bg-dark-surface/95 backdrop-blur-xl rounded-t-3xl p-2 md:p-3 shadow-2xl border-t border-white/10">
                <!-- Canvas for swipe trail -->
                <canvas id="swipeCanvas" class="absolute inset-0 z-10"></canvas>
                
                <!-- Keyboard -->
                <div class="space-y-1.5 md:space-y-2" id="keyboard">
                    <!-- Row 1: QWERTYUIOP -->
                    <div class="flex justify-center gap-1 md:gap-1.5 px-1">
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="q" data-row="0" data-col="0">Q</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="w" data-row="0" data-col="1">W</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="e" data-row="0" data-col="2">E</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="r" data-row="0" data-col="3">R</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="t" data-row="0" data-col="4">T</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="y" data-row="0" data-col="5">Y</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="u" data-row="0" data-col="6">U</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="i" data-row="0" data-col="7">I</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="o" data-row="0" data-col="8">O</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="p" data-row="0" data-col="9">P</button>
                    </div>
                    
                    <!-- Row 2: ASDFGHJKL -->
                    <div class="flex justify-center gap-1 md:gap-1.5 px-4 md:px-6">
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="a" data-row="1" data-col="0">A</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="s" data-row="1" data-col="1">S</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="d" data-row="1" data-col="2">D</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="f" data-row="1" data-col="3">F</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="g" data-row="1" data-col="4">G</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="h" data-row="1" data-col="5">H</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="j" data-row="1" data-col="6">J</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="k" data-row="1" data-col="7">K</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="l" data-row="1" data-col="8">L</button>
                    </div>
                    
                    <!-- Row 3: Shift + ZXCVBNM + Backspace -->
                    <div class="flex justify-center gap-1 md:gap-1.5 px-1">
                        <button class="key w-14 h-12 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 text-sm transition-all border border-white/5" data-key="shift">â‡§</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="z" data-row="2" data-col="1">Z</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="x" data-row="2" data-col="2">X</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="c" data-row="2" data-col="3">C</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="v" data-row="2" data-col="4">V</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="b" data-row="2" data-col="5">B</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="n" data-row="2" data-col="6">N</button>
                        <button class="key flex-1 h-12 bg-dark-key hover:bg-dark-key-hover rounded-lg text-white text-xl font-light transition-all border border-white/5" data-key="m" data-row="2" data-col="7">M</button>
                        <button class="key w-14 h-12 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 text-sm transition-all border border-white/5" data-key="backspace" onclick="handleBackspace()">âŒ«</button>
                    </div>
                    
                    <!-- Row 4: Special keys -->
                    <div class="flex justify-center gap-1 md:gap-1.5 px-1">
                        <button class="w-16 h-12 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 text-sm transition-all border border-white/5" onclick="toggleNumberMode()" data-special="number-toggle">123</button>
                        <button class="w-12 h-12 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 text-sm transition-all border border-white/5" onclick="toggleEmojiMode()" data-special="emoji-toggle">ðŸ˜Š</button>
                        <button class="flex-1 h-12 bg-gray-800 hover:bg-gray-700 rounded-lg text-gray-400 text-sm transition-all border border-white/5" onclick="handleSpace()" data-special="space">space</button>
                        <button class="w-20 h-12 bg-gradient-to-r from-neon-blue/20 to-neon-purple/20 hover:from-neon-blue/30 hover:to-neon-purple/30 rounded-lg text-white text-sm transition-all border border-neon-blue/30" onclick="handleReturn()" data-special="return">return</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>        // Configuration
        const NORMALIZED_WIDTH = 360;
        const NORMALIZED_HEIGHT = 215;
        const MAX_SEQUENCE_LENGTH = 150;  // Fixed sequence length from training - cannot change without retraining model
        const DEBUG = { enabled: false };
        
        // Model variables
        let encoderSession = null;
        let decoderSession = null;
        let tokenizer = null;
        let isModelReady = false;
        let swipeVocabulary = null;  // Using new SwipeVocabulary class
        let commonTwoCharWords = null;

        // RNNT runtime variables
        let runtimeMeta = null;
        let wordList = null;
        let wordLogPrior = null; // Word frequency priors for beam search
        let trieRoot = null;
        
        // Expose for debugging
        window.isModelReady = false;
        
        // Canvas setup
        const canvas = document.getElementById('swipeCanvas');
        const ctx = canvas.getContext('2d');
        
        // Swipe tracking
        let isDrawing = false;
        let isPotentialSwipe = false; // Track if this might actually be a swipe
        let swipePath = [];
        let keySequence = [];
        let currentKey = null;
        let keyboardBounds = null;
        let inputText = '';
        let swipeStartPos = null;
        let swipeStartTime = null;
        let tapTimeout = null;
        
        // Helper functions for RNNT beam search
        async function fetchText(url) {
            return await (await fetch(url)).text();
        }

        async function fetchJSON(url) {
            return await (await fetch(url)).json();
        }

        function normalizeWord(w) {
            return w.toLowerCase().replace(/\u2019/g, "'");
        }

        function buildTrie(words, charToId) {
            const node = () => ({ children: new Map(), isWord: false, wid: -1 });
            const root = node();
            let kept = 0;

            words.forEach((w, wid) => {
                w = normalizeWord(w);
                if (![...w].every(ch => charToId.has(ch))) return;
                let cur = root;
                for (const ch of w) {
                    const cid = charToId.get(ch);
                    if (!cur.children.has(cid)) cur.children.set(cid, node());
                    cur = cur.children.get(cid);
                }
                cur.isWord = true;
                cur.wid = wid;
                kept++;
            });

            console.log(`Trie built: ${kept}/${words.length} words kept`);
            return root;
        }

        function zeros(shape, dtype) {
            const n = shape.reduce((a, b) => a * b, 1);
            const buf = dtype === "float32" ? new Float32Array(n) :
                        dtype === "int32" ? new Int32Array(n) :
                        new BigInt64Array(n);
            return new ort.Tensor(dtype, buf, shape);
        }

        function sliceLC(all, i, L, H) {
            const out = zeros([L, 1, H], "float32");
            const src = all.data;
            const dst = out.data;
            const N = all.dims[1];

            for (let l = 0; l < L; l++) {
                const srcBase = (l * N + i) * H;
                const dstBase = l * H;
                dst.set(src.subarray(srcBase, srcBase + H), dstBase);
            }
            return out;
        }

        // Initialize ONNX Runtime and load models
        async function loadModels() {
            try {
                updateLoadingStatus('Initializing ONNX Runtime...');
                
                // Configure ONNX Runtime Web WASM paths
                if (typeof ort !== 'undefined') {
                    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/';
                    console.log('ONNX Runtime initialized, version:', ort.env.versions?.onnxruntime);
                } else {
                    throw new Error('ONNX Runtime not loaded');
                }
                
                // Load tokenizer config first
                updateLoadingStatus('Loading tokenizer...');
                const tokenizerResponse = await fetch('tokenizer_config.json');
                tokenizer = await tokenizerResponse.json();
                console.log('Tokenizer loaded:', tokenizer);
                
                updateLoadingStatus('Loading encoder model...');
                
                // Load ONNX models with optimal performance settings
                const sessionOptions = {
                    executionProviders: ['webgpu', 'wasm'],
                    graphOptimizationLevel: 'all',
                    enableCpuMemArena: false, // Reduce memory overhead
                    enableMemPattern: false,  // Disable pattern matching for speed
                    executionMode: 'sequential' // Sequential execution for deterministic timing
                };
                
                encoderSession = await ort.InferenceSession.create('encoder_web_ultra_web_final.onnx', sessionOptions);
                console.log('Ultra-optimized encoder model loaded (25MB INT8)');

                // Log input/output names for debugging
                console.log('Model inputs:', encoderSession.inputNames);
                console.log('Model outputs:', encoderSession.outputNames);

                // Load decoder model - required for beam search decoding
                updateLoadingStatus('Loading RNNT step model...');
                decoderSession = await ort.InferenceSession.create('rnnt_step_fp32.onnx', sessionOptions);
                console.log('RNNT step model loaded (8MB FP32)');
                console.log('Step model inputs:', decoderSession.inputNames);
                console.log('Step model outputs:', decoderSession.outputNames);

                // Load runtime metadata and vocabulary for RNNT beam search
                updateLoadingStatus('Loading runtime metadata...');
                runtimeMeta = await fetchJSON('runtime_meta.json');
                console.log('Runtime metadata loaded:', runtimeMeta);

                updateLoadingStatus('Loading vocabulary wordlist...');
                const wordsText = await fetchText('words.txt');
                wordList = wordsText.split(/\r?\n/).filter(s => s.length > 0);
                console.log(`Vocabulary wordlist loaded: ${wordList.length} words`);

                // Calculate word frequency priors (assuming words.txt is frequency-sorted)
                const totalWords = wordList.length;
                wordLogPrior = new Float32Array(totalWords);
                for (let i = 0; i < totalWords; i++) {
                    // Simple inverse rank priority for frequency-sorted list
                    const pseudo_freq = totalWords - i;
                    wordLogPrior[i] = Math.log(pseudo_freq / totalWords);
                }
                console.log(`Word frequency priors calculated: ${wordLogPrior.length} entries`);

                // Build trie for lexicon-constrained beam search
                updateLoadingStatus('Building trie...');
                const charToId = new Map(Object.entries(runtimeMeta.char_to_id));
                trieRoot = buildTrie(wordList, charToId);
                console.log('Trie built successfully');
                
                // Load vocabulary dictionary
                updateLoadingStatus('Loading vocabulary...');
                await loadVocabulary();

                // Warm up models with dummy inference for optimal first-run performance
                updateLoadingStatus('Warming up models...');
                console.log('ðŸ”¥ Warming up RNNT pipeline for optimal performance...');

                try {
                    // Create dummy features for warmup
                    const dummyF = 37, dummyT = 20;
                    const dummyFeatures = new Float32Array(dummyF * dummyT);
                    for (let i = 0; i < dummyFeatures.length; i++) {
                        dummyFeatures[i] = Math.random() * 0.1; // Small random values
                    }

                    // Warm up encoder
                    const warmupStart = performance.now();
                    const encOut = await encoderSession.run({
                        features_bft: new ort.Tensor("float32", dummyFeatures, [1, dummyF, dummyT]),
                        lengths: new ort.Tensor("int32", new Int32Array([dummyT]), [1]),
                    });

                    // Warm up step model with dummy state
                    const dummyH = zeros([2, 1, 320], "float32");
                    const dummyC = zeros([2, 1, 320], "float32");
                    const dummyEnc = new Float32Array(256);

                    await decoderSession.run({
                        y_prev: new ort.Tensor("int64", new BigInt64Array([BigInt(runtimeMeta.blank_id)]), [1]),
                        h0: dummyH,
                        c0: dummyC,
                        enc_t: new ort.Tensor("float32", dummyEnc, [1, 256]),
                    });

                    const warmupTime = performance.now() - warmupStart;
                    console.log(`âœ… Model warmup completed in ${warmupTime.toFixed(1)}ms`);
                } catch (error) {
                    console.warn('âš ï¸ Model warmup failed (non-critical):', error);
                }

                isModelReady = true;
                window.isModelReady = true;  // Expose for debugging
                hideLoadingOverlay();
                updateStatus('Ready', 'success');
                console.log('ðŸš€ RNNT pipeline fully initialized and ready for real-time inference!');
                
            } catch (error) {
                console.error('Error loading models:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                updateStatus('Model loading failed - check console', 'error');
                hideLoadingOverlay();
                
                // More detailed error message
                updateLoadingStatus(`Error: ${error.message || 'Unknown error'}`);
                
                // Display error in UI
                const suggestionsDiv = document.getElementById('suggestions');
                if (suggestionsDiv) {
                    suggestionsDiv.innerHTML = `<div class="text-red-500 p-2">Error loading models: ${error.message}</div>`;
                }
            }
        }
        
        // Load vocabulary for spell correction
        async function loadVocabulary() {
            console.log('Starting vocabulary load...');
            try {
                // Initialize the SwipeVocabulary instance
                swipeVocabulary = new SwipeVocabulary();
                
                // Try loading the optimized JSON vocabulary first
                const jsonSuccess = await swipeVocabulary.loadFromJSON('swipe_vocabulary.json');
                
                if (jsonSuccess) {
                    console.log('Loaded optimized vocabulary:', swipeVocabulary.getStats());
                    
                    // Initialize custom dictionary support immediately
                    initializeCustomDictionaryIntegration();
                    
                    // Extract common two-char words for backward compatibility
                    commonTwoCharWords = Array.from(swipeVocabulary.wordFreq.keys())
                        .filter(w => w.length === 2)
                        .slice(0, 50);
                    
                    return;
                }
                
                // Fallback to text file if JSON fails
                console.log('JSON vocabulary not found, trying text format...');
                const vocabUrl = 'vocabulary_words.txt';
                const response = await fetch(vocabUrl);
                
                if (!response.ok) {
                    throw new Error(`Vocabulary file not found (${response.status}). Please ensure swipe_vocabulary.json is available.`);
                }
                
                const text = await response.text();
                const lines = text.split('\n');
                console.log('Text vocabulary lines count:', lines.length);
                
                // Convert text format to vocabulary structure
                const wordFreqMap = new Map();
                lines.forEach((line, index) => {
                    const word = line.trim().toLowerCase();
                    if (word && word.match(/^[a-z]+$/)) {
                        // Assign decreasing frequency based on position
                        const freq = 1e-4 * Math.pow(0.99, index);
                        wordFreqMap.set(word, freq);
                    }
                });
                
                // Initialize swipeVocabulary with text data
                swipeVocabulary = new SwipeVocabulary();
                swipeVocabulary.wordFreq = wordFreqMap;
                swipeVocabulary.commonWords = new Set(
                    Array.from(wordFreqMap.keys()).slice(0, 5000)
                );
                swipeVocabulary.top5000 = swipeVocabulary.commonWords;
                swipeVocabulary.isLoaded = true;
                
                // Initialize custom dictionary support immediately
                initializeCustomDictionaryIntegration();
                
                // Extract common two-char words for backward compatibility
                commonTwoCharWords = Array.from(wordFreqMap.keys())
                    .filter(w => w.length === 2)
                    .slice(0, 50);
                
                console.log(`Loaded text vocabulary with ${wordFreqMap.size} words`);
                
            } catch (error) {
                console.error('Error loading vocabulary:', error);
                throw error; // Fail fast - vocabulary is required for RNNT beam search
            }
        }
        
        // Fast Levenshtein distance calculation
        function levenshteinDistance(s1, s2) {
            if (s1 === s2) return 0;
            if (s1.length === 0) return s2.length;
            if (s2.length === 0) return s1.length;
            
            // Use single array optimization
            const prevRow = new Array(s2.length + 1);
            const currRow = new Array(s2.length + 1);
            
            // Initialize first row
            for (let j = 0; j <= s2.length; j++) {
                prevRow[j] = j;
            }
            
            for (let i = 0; i < s1.length; i++) {
                currRow[0] = i + 1;
                
                for (let j = 0; j < s2.length; j++) {
                    const cost = s1[i] === s2[j] ? 0 : 1;
                    currRow[j + 1] = Math.min(
                        prevRow[j + 1] + 1,     // deletion
                        currRow[j] + 1,          // insertion
                        prevRow[j] + cost        // substitution
                    );
                }
                
                // Swap arrays
                [prevRow, currRow] = [currRow, prevRow];
            }
            
            return prevRow[s2.length];
        }
        
        // Find closest word in dictionary
        function findClosestWord(input, maxDistance = 2) {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) return input;
            
            input = input.toLowerCase();
            
            // If exact match exists, return it
            if (swipeVocabulary.hasWord(input)) {
                return input;
            }
            
            // For very short words, be more strict
            if (input.length <= 3) {
                maxDistance = 1;
            }
            
            let bestMatch = input;
            let bestDistance = maxDistance + 1;
            let bestFrequency = Infinity;
            
            // Use SwipeVocabulary's similar word finder
            const similarWords = swipeVocabulary.getSimilarWords(input, 1);
            if (similarWords.length > 0) {
                return similarWords[0].word;
            }
            
            return input;
        }
        
        // Calculate total distance of swipe path
        function getSwipeDistance(path) {
            if (path.length < 2) return 0;
            
            let totalDistance = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i-1].x;
                const dy = path[i].y - path[i-1].y;
                totalDistance += Math.sqrt(dx * dx + dy * dy);
            }
            return totalDistance;
        }
        
        // Check if swipe path is nearly straight
        function isNearlyStraightLine(path) {
            if (path.length < 3) return false;
            
            // Calculate variance from straight line
            const startPoint = path[0];
            const endPoint = path[path.length - 1];
            
            // Vector from start to end
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);
            
            if (lineLength < 50) return false; // Too short
            
            // Check deviation of middle points
            let maxDeviation = 0;
            
            for (let i = 1; i < path.length - 1; i++) {
                const point = path[i];
                
                // Calculate perpendicular distance to line
                const t = Math.max(0, Math.min(1, 
                    ((point.x - startPoint.x) * dx + (point.y - startPoint.y) * dy) / (lineLength * lineLength)
                ));
                
                const projX = startPoint.x + t * dx;
                const projY = startPoint.y + t * dy;
                
                const deviation = Math.sqrt(
                    Math.pow(point.x - projX, 2) + Math.pow(point.y - projY, 2)
                );
                
                maxDeviation = Math.max(maxDeviation, deviation);
            }
            
            // Consider straight if max deviation is less than 15% of line length
            return maxDeviation < lineLength * 0.15;
        }
        
        // Get potential two-character word from start and end keys
        function getTwoCharWordFromSwipe(keySequence) {
            if (!keySequence || keySequence.length === 0 || !swipeVocabulary || !swipeVocabulary.isLoaded) return null;
            
            const startKey = keySequence[0]?.key;
            const endKey = keySequence[keySequence.length - 1]?.key;
            
            if (startKey && endKey && startKey !== endKey) {
                const twoCharWord = startKey + endKey;
                // Only return if it's a valid word in the vocabulary
                if (swipeVocabulary.hasWord(twoCharWord)) {
                    console.log(`Found valid 2-char word from swipe: ${twoCharWord}`);
                    return twoCharWord;
                }
            }
            
            return null;
        }
        
        function updateLoadingStatus(message) {
            document.getElementById('loadingDetails').textContent = message;
        }
        
        function hideLoadingOverlay() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        
        function updateStatus(message, type = 'info') {
            const statusText = document.getElementById('statusText');
            const statusIndicator = document.getElementById('statusIndicator');
            const modelStatus = document.getElementById('modelStatus');
            
            statusText.textContent = message;
            
            if (type === 'success') {
                statusIndicator.className = 'w-2 h-2 bg-neon-blue rounded-full animate-pulse-neon';
                modelStatus.textContent = 'ONNX Models Ready â€¢ Character-level Transformer';
            } else if (type === 'error') {
                statusIndicator.className = 'w-2 h-2 bg-red-500 rounded-full';
                modelStatus.textContent = 'Models Failed to Load';
            } else {
                statusIndicator.className = 'w-2 h-2 bg-yellow-500 rounded-full';
            }
        }
        
        // Initialize canvas and keyboard
        async function init() {
            resizeCanvas();
            updateKeyboardBounds();
            
            // Load models (which includes vocabulary loading)
            await loadModels();
            
            window.addEventListener('resize', () => {
                resizeCanvas();
                updateKeyboardBounds();
            });
        }
        
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
        
        function updateKeyboardBounds() {
            const keys = document.querySelectorAll('.key[data-row]');
            if (keys.length === 0) return;
            
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            keys.forEach(key => {
                const rect = key.getBoundingClientRect();
                minX = Math.min(minX, rect.left);
                minY = Math.min(minY, rect.top);
                maxX = Math.max(maxX, rect.right);
                maxY = Math.max(maxY, rect.bottom);
            });
            
            keyboardBounds = { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
        }        
        function getEventPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top, clientX, clientY };
        }
        
        function getNormalizedCoords(clientX, clientY) {
            if (!keyboardBounds) return { x: 0, y: 0, normalized: { x: 0, y: 0 } };
            
            const x = clientX - keyboardBounds.minX;
            const y = clientY - keyboardBounds.minY;
            
            // Normalize to 360x215 space
            const normX = (x / keyboardBounds.width) * NORMALIZED_WIDTH;
            const normY = (y / keyboardBounds.height) * NORMALIZED_HEIGHT;
            
            // Also calculate 0-1 range
            const norm01X = x / keyboardBounds.width;
            const norm01Y = y / keyboardBounds.height;
            
            return {
                x: Math.round(normX),
                y: Math.round(normY),
                normalized: { x: norm01X.toFixed(3), y: norm01Y.toFixed(3) }
            };
        }
        
        function getKeyAtPosition(clientX, clientY) {
            const keys = document.querySelectorAll('.key[data-key]:not([data-special])');
            for (let key of keys) {
                const rect = key.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= rect.top && clientY <= rect.bottom) {
                    return key;
                }
            }
            return null;
        }        
        function startSwipe(e) {
            const pos = getEventPosition(e);
            const coords = getNormalizedCoords(pos.clientX, pos.clientY);
            const key = getKeyAtPosition(pos.clientX, pos.clientY);
            
            // If starting on a key, set up tap detection timer
            if (key) {
                swipeStartPos = { x: pos.clientX, y: pos.clientY };
                swipeStartTime = Date.now();
                currentKey = key.dataset.key;
                
                // Set timer to detect if this is a tap (no movement after 150ms)
                tapTimeout = setTimeout(() => {
                    // If we get here, it's likely a tap
                    if (isDrawing && !isPotentialSwipe) {
                        console.log('ðŸ‘† Detected as TAP (timer expired without movement)');
                        handleSingleTap(key);
                        cancelSwipe();
                    }
                }, 150);
                
                key.classList.add('key-active');
            }
            
            // Always start drawing state but don't commit to swipe yet
            isDrawing = true;
            isPotentialSwipe = false;
            swipePath = [];
            keySequence = [];
            
            // Auto-select top prediction if user starts new input without manual selection
            if (hasPendingPredictions && !userMadeManualSelection && currentPredictions.length > 0) {
                autoSelectTopPrediction();
            }
            
            // Clear tap typing state when starting any gesture
            currentTypedWord = '';
            
            swipePath.push({
                x: coords.x,
                y: coords.y,
                normalized: coords.normalized,
                key: currentKey,
                timestamp: Date.now()
            });
            
            if (key) {
                keySequence.push({ key: currentKey, timestamp: Date.now(), index: 0 });
            }
            
            if (DEBUG.enabled) {
                updateDebugDisplay(coords, currentKey);
                document.getElementById('coordinateDisplay').classList.remove('hidden');
            }
        }
        
        function continueSwipe(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getEventPosition(e);
            const coords = getNormalizedCoords(pos.clientX, pos.clientY);
            const key = getKeyAtPosition(pos.clientX, pos.clientY);
            
            // Check if this is now definitely a swipe (movement threshold)
            if (!isPotentialSwipe && swipeStartPos) {
                const distance = Math.sqrt(
                    Math.pow(pos.clientX - swipeStartPos.x, 2) + 
                    Math.pow(pos.clientY - swipeStartPos.y, 2)
                );
                
                // If moved more than 15px, it's definitely a swipe
                if (distance > 15) {
                    isPotentialSwipe = true;
                    // Cancel the tap timeout
                    if (tapTimeout) {
                        clearTimeout(tapTimeout);
                        tapTimeout = null;
                    }
                    console.log('ðŸ”„ Converted TAP to SWIPE (movement detected)');
                }
            }
            
            // Track significant key changes only (ignore rapid flickering)
            const keyChar = key ? key.dataset.key : null;
            if (keyChar !== currentKey && keyChar) {
                // Only record key if we haven't been there recently (reduce noise)
                const recentKeys = keySequence.slice(-5).map(k => k.key);
                const shouldRecord = !recentKeys.includes(keyChar) || keySequence.length === 0;

                if (shouldRecord) {
                    // Remove highlight from previous key
                    if (currentKey) {
                        document.querySelector(`.key[data-key="${currentKey}"]`)?.classList.remove('key-active');
                    }

                    // Add highlight to new key
                    key.classList.add('key-active');
                    keySequence.push({
                        key: keyChar,
                        timestamp: Date.now(),
                        index: swipePath.length
                    });

                    currentKey = keyChar;
                }
            }

            // Multiple keys = definitely a swipe
            if (keySequence.length > 1 && !isPotentialSwipe) {
                isPotentialSwipe = true;
                if (tapTimeout) {
                    clearTimeout(tapTimeout);
                    tapTimeout = null;
                }
                console.log('ðŸ”„ Converted TAP to SWIPE (multiple keys)');
            }
            
            swipePath.push({
                x: coords.x,
                y: coords.y,
                normalized: coords.normalized,
                key: currentKey,
                timestamp: Date.now()
            });
            
            // Only draw trail for confirmed swipes
            if (isPotentialSwipe) {
                drawNeonTrail();
            }
            
            if (DEBUG.enabled) {
                updateDebugDisplay(coords, currentKey);
            }
        }        
        function drawNeonTrail() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (swipePath.length < 2) return;
            
            // Create gradient effect
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#00d4ff');
            gradient.addColorStop(0.5, '#b300ff');
            gradient.addColorStop(1, '#ff00d4');
            
            // Draw multiple layers for glow effect
            for (let layer = 3; layer > 0; layer--) {
                ctx.strokeStyle = gradient;
                ctx.lineWidth = layer * 2;
                ctx.globalAlpha = 0.3 / layer;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Add glow
                ctx.shadowColor = layer === 1 ? '#00d4ff' : '#b300ff';
                ctx.shadowBlur = 15 * layer;
                
                ctx.beginPath();
                swipePath.forEach((point, i) => {
                    const canvasX = (point.x / NORMALIZED_WIDTH) * keyboardBounds.width;
                    const canvasY = (point.y / NORMALIZED_HEIGHT) * keyboardBounds.height;
                    
                    if (i === 0) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                });
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            
            // Draw dots at key positions
            keySequence.forEach((keyEvent, i) => {
                const keyEl = document.querySelector(`.key[data-key="${keyEvent.key}"]`);
                if (keyEl) {
                    const rect = keyEl.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    const x = rect.left + rect.width/2 - canvasRect.left;
                    const y = rect.top + rect.height/2 - canvasRect.top;
                    
                    ctx.fillStyle = '#00d4ff';
                    ctx.shadowColor = '#00d4ff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }        
        // Handle single tap (no swipe processing)
        function handleSingleTap(keyElement) {
            if (keyElement && keyElement.dataset.key) {
                console.log('Processing single tap:', keyElement.dataset.key);
                handleSingleCharacterInput(keyElement.dataset.key);
            }
        }
        
        // Handle pure single character input (no predictions)
        function handleSingleCharacterInput(keyValue) {
            if (keyValue && keyValue.length === 1) {
                // Handle different character types
                if (keyValue.match(/[a-z]/i)) {
                    // Letters - lowercase for consistency
                    inputText += keyValue.toLowerCase();
                } else if (keyValue.match(/[0-9-/();$&@"'.,?!+*]/)) {
                    // Numbers and symbols - add as-is
                    inputText += keyValue;
                } else if (keyValue.match(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/u)) {
                    // Emojis - add as-is
                    inputText += keyValue;
                } else {
                    // Other single characters
                    inputText += keyValue;
                }
                
                document.getElementById('inputText').textContent = inputText;
                console.log(`ðŸ“ Added character: "${keyValue}" (total: "${inputText}")`);
                
                // Clear any existing predictions since this is direct character input
                clearPredictionState();
                
            } else {
                // Handle special keys for single taps
                switch (keyValue) {
                    case 'backspace':
                        handleBackspace();
                        break;
                    case 'space':
                        inputText += ' ';
                        document.getElementById('inputText').textContent = inputText;
                        console.log('ðŸ“ Added space');
                        break;
                    case 'shift':
                        handleShift();
                        break;
                    default:
                        console.log(`Special key tapped: ${keyValue}`);
                }
            }
        }
        
        // Handle shift key functionality
        function handleShift() {
            // Toggle shift state
            const isShiftActive = document.querySelector('.key[data-key="shift"]')?.classList.contains('key-active');
            
            if (isShiftActive) {
                // Turn off shift
                document.querySelector('.key[data-key="shift"]')?.classList.remove('key-active');
                console.log('ðŸ”¤ Shift OFF');
            } else {
                // Turn on shift
                document.querySelector('.key[data-key="shift"]')?.classList.add('key-active');
                console.log('ðŸ”¤ Shift ON');
                
                // Auto turn off after next character
                setTimeout(() => {
                    document.querySelector('.key[data-key="shift"]')?.classList.remove('key-active');
                }, 3000); // Auto-off after 3 seconds
            }
        }
        
        // Cancel swipe and clean up
        function cancelSwipe() {
            isDrawing = false;
            isPotentialSwipe = false;
            
            // Clear timeout
            if (tapTimeout) {
                clearTimeout(tapTimeout);
                tapTimeout = null;
            }
            
            // Clear highlights
            document.querySelectorAll('.key-active').forEach(key => {
                key.classList.remove('key-active');
            });
            
            // Clear canvas and reset
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            swipePath = [];
            keySequence = [];
            currentKey = null;
            swipeStartPos = null;
            swipeStartTime = null;
        }
        
        function endSwipe(e) {
            if (!isDrawing) return;
            
            // Clear the tap timeout if it's still running
            if (tapTimeout) {
                clearTimeout(tapTimeout);
                tapTimeout = null;
            }
            
            isDrawing = false;
            
            // Clear all key highlights
            document.querySelectorAll('.key-active').forEach(key => {
                key.classList.remove('key-active');
            });
            
            // Process gesture - only if it was determined to be a swipe
            if (swipePath.length > 0 && isPotentialSwipe) {
                const swipeData = {
                    path: swipePath,
                    keySequence: keySequence,
                    duration: swipePath[swipePath.length - 1].timestamp - swipePath[0].timestamp,
                    word: keySequence.map(k => k.key).join('')
                };
                
                console.log(`ðŸŒ€ SWIPE detected (path=${swipePath.length}, duration=${swipeData.duration}ms, keys=${keySequence.length}, distance=${getSwipeDistance(swipePath).toFixed(1)}px)`);
                console.log('Swipe Data:', swipeData);
                
                if (DEBUG.enabled) {
                    displaySwipeOutput(swipeData);
                }
                
                // Send to model for swipe processing
                processSwipe(swipeData);
                
            } else if (swipePath.length > 0 && !isPotentialSwipe) {
                // This was a short gesture that didn't become a swipe
                const endPos = getEventPosition(e);
                const key = getKeyAtPosition(endPos.clientX, endPos.clientY);
                
                if (key && key === getKeyAtPosition(swipeStartPos.x, swipeStartPos.y)) {
                    // Started and ended on same key - definitely a tap
                    console.log('ðŸ‘† TAP detected (same key start/end)');
                    handleSingleTap(key);
                } else {
                    console.log('ðŸ“ Short gesture - treating as tap on start key');
                    const startKey = getKeyAtPosition(swipeStartPos.x, swipeStartPos.y);
                    if (startKey) {
                        handleSingleTap(startKey);
                    }
                }
            }
            
            // Clear trail after delay
            setTimeout(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (DEBUG.enabled) {
                    document.getElementById('coordinateDisplay').classList.add('hidden');
                }
            }, 300);
        }        
        // Process swipe path and generate predictions
        async function processSwipe(swipeData) {
            if (!isModelReady) {
                console.warn('Models not ready yet');
                return;
            }
            
            try {
                updateStatus('Processing swipe...', 'processing');
                
                // Prepare input features from swipe path
                const features = prepareSwipeFeatures(swipeData);
                
                // Run inference
                const predictions = await runInference(features);
                
                // Display predictions
                displayPredictions(predictions);
                
                updateStatus('Ready', 'success');
                
            } catch (error) {
                console.error('âŒ Error processing swipe:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                // Check what failed
                console.error('Model state check:', {
                    encoderSession: encoderSession ? 'loaded' : 'missing',
                    decoderSession: decoderSession ? 'loaded' : 'missing',
                    runtimeMeta: runtimeMeta ? 'loaded' : 'missing',
                    wordList: wordList ? `${wordList.length} words` : 'missing',
                    trieRoot: trieRoot ? 'loaded' : 'missing',
                    isModelReady: isModelReady
                });

                updateStatus(`Processing error: ${error.message}`, 'error');
            }
        }
        
        function prepareSwipeFeatures(swipeData) {
            // Normalize swipe path to fixed length
            const path = swipeData.path;
            const normalizedPath = [];
            const originalLength = Math.min(path.length, MAX_SEQUENCE_LENGTH);
            
            // Take up to MAX_SEQUENCE_LENGTH points and normalize to [0, 1] range
            for (let i = 0; i < Math.min(path.length, MAX_SEQUENCE_LENGTH); i++) {
                const point = path[i];
                normalizedPath.push({
                    x: parseFloat(point.normalized.x), // Already normalized [0,1] by getNormalizedCoords
                    y: parseFloat(point.normalized.y), // Already normalized [0,1] by getNormalizedCoords
                    t: point.timestamp, // Keep original timestamp for relative time calc
                    key: point.key || null
                });
            }
            
            // Pad with last point if too short (use center point in [0,1] range)
            const lastPoint = normalizedPath[normalizedPath.length - 1] || { x: 0.5, y: 0.5, t: 0, key: null };
            while (normalizedPath.length < MAX_SEQUENCE_LENGTH) {
                normalizedPath.push({ ...lastPoint });
            }
            
            return {
                path: normalizedPath,
                originalLength: originalLength,  // Track actual swipe length for masking
                keySequence: swipeData.keySequence,
                duration: swipeData.duration
            };
        }

        // Helper function to get key position for feature extraction
        function getKeyPosition(key) {
            const keyElement = document.querySelector(`button[data-key="${key}"]`);
            if (!keyElement) return null;

            const rect = keyElement.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();

            return {
                x: (rect.left + rect.width/2 - canvasRect.left) / canvasRect.width,
                y: (rect.top + rect.height/2 - canvasRect.top) / canvasRect.height
            };
        }

        // Core RNNT word beam search function
        async function rnntWordBeam(
            encoder, step, featuresBFT, F, T, L, H, D, meta, words, trieRoot, wordLogPrior,
            opts = { beamSize: 16, prunePerBeam: 6, maxSymbols: 20, lmLambda: 0.4, topK: 5 }
        ) {
            const encOut = await encoder.run({
                features_bft: new ort.Tensor("float32", featuresBFT, [1, F, T]),
                lengths: new ort.Tensor("int32", new Int32Array([T]), [1]),
            });

            const encBDT = encOut["encoded_btf"]; // (1,D,T_out) - encoder outputs [B, D, T]
            const D_actual = encBDT.dims[1]; // D dimension
            const T_out = encBDT.dims[2]; // T_out dimension

            // Transpose from [B, D, T] to [B, T, D] for beam search
            const enc = new Float32Array(T_out * D_actual);
            const srcData = encBDT.data;

            for (let t = 0; t < T_out; t++) {
                for (let d = 0; d < D_actual; d++) {
                    enc[t * D_actual + d] = srcData[d * T_out + t];
                }
            }

            let beams = [{
                yPrev: BigInt(meta.blank_id),
                h: zeros([L, 1, H], "float32"),
                c: zeros([L, 1, H], "float32"),
                trie: trieRoot,
                logp: 0,
                chars: []
            }];

            const enc_t_batch = new Float32Array(opts.beamSize * D_actual);

            for (let t = 0; t < T_out; t++) {
                for (let s = 0; s < opts.maxSymbols; s++) {
                    beams.sort((a, b) => b.logp - a.logp);
                    const N = Math.min(opts.beamSize, beams.length);
                    const act = beams.slice(0, N);

                    const yPrev = new BigInt64Array(N);
                    const h0 = zeros([L, N, H], "float32");
                    const c0 = zeros([L, N, H], "float32");

                    for (let i = 0; i < N; i++) {
                        yPrev[i] = act[i].yPrev;
                        h0.data.set(act[i].h.data, i * L * H);
                        c0.data.set(act[i].c.data, i * L * H);
                    }

                    const base = t * D_actual;
                    for (let i = 0; i < N; i++) {
                        enc_t_batch.set(enc.subarray(base, base + D_actual), i * D_actual);
                    }

                    // Create properly sized tensor for enc_t (only use the portion we need)
                    const enc_t_tensor_data = enc_t_batch.slice(0, N * D_actual);

                    const out = await step.run({
                        y_prev: new ort.Tensor("int64", yPrev, [N]),
                        h0,
                        c0,
                        enc_t: new ort.Tensor("float32", enc_t_tensor_data, [N, D_actual]),
                    });

                    const logits = out["logits"];
                    const V = logits.dims[1];
                    const logBuf = logits.data;
                    const h1 = out["h1"];
                    const c1 = out["c1"];

                    const next = [];
                    for (let i = 0; i < N; i++) {
                        // blank transition
                        const lpBlank = logBuf[i * V + meta.blank_id];
                        next.push({
                            yPrev: BigInt(meta.blank_id),
                            h: sliceLC(h1, i, L, H),
                            c: sliceLC(c1, i, L, H),
                            trie: act[i].trie,
                            logp: act[i].logp + lpBlank,
                            chars: act[i].chars.slice()
                        });

                        // allowed children (trie constraint)
                        const allowed = Array.from(act[i].trie.children.keys());
                        if (allowed.length) {
                            allowed.sort((a, b) => logBuf[i * V + b] - logBuf[i * V + a]);
                            for (const cid of allowed.slice(0, Math.min(opts.prunePerBeam, allowed.length))) {
                                next.push({
                                    yPrev: BigInt(cid),
                                    h: sliceLC(h1, i, L, H),
                                    c: sliceLC(c1, i, L, H),
                                    trie: act[i].trie.children.get(cid),
                                    logp: act[i].logp + logBuf[i * V + cid],
                                    chars: act[i].chars.concat(cid)
                                });
                            }
                        }
                    }
                    next.sort((a, b) => b.logp - a.logp);
                    beams = next.slice(0, opts.beamSize);
                    if (Number(beams[0].yPrev) === meta.blank_id) break;
                }
            }

            // collect terminals
            const cands = [];
            for (const b of beams) {
                if (b.trie.isWord && b.trie.wid >= 0) {
                    const wid = b.trie.wid;
                    const lm = wordLogPrior ? wordLogPrior[wid] : 0;
                    cands.push({ wid, score: b.logp + opts.lmLambda * lm, rnnt: b.logp });
                }
            }

            cands.sort((a, b) => b.score - a.score);
            const seen = new Set();
            const out = [];

            console.log('ðŸ” Beam search candidates:', cands.length);
            for (let i = 0; i < Math.min(10, cands.length); i++) {
                const c = cands[i];
                console.log(`  Candidate ${i}: wid=${c.wid}, word="${words[c.wid]}", score=${c.score.toFixed(3)}`);
            }

            for (const c of cands) {
                if (seen.has(c.wid)) continue;
                seen.add(c.wid);
                out.push({ word: words[c.wid], score: c.score, rnnt: c.rnnt });
                if (out.length >= opts.topK) break;
            }

            console.log('ðŸŽ¯ Final beam search output:', out.map(o => o.word));
            return out;
        }

        async function runInference(features) {
            const startTime = performance.now();

            // Convert swipe features to RNNT format
            // RNNT encoder expects features_bft: [B, F, T] where F=37 features
            const T = features.path.length;
            const F = 37; // RNNT feature dimension
            const featuresBFT = new Float32Array(1 * F * T);

            console.log(`ðŸ”¥ Starting inference for ${T} time steps`);

            // SwipeFeaturizer: Extract 37D features matching EXACT training format
            // Create keyboard layout mapping for key distances (QWERTY)
            const layout = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'];
            const charToPos = {};
            const chars = 'abcdefghijklmnopqrstuvwxyz';

            for (let rowIdx = 0; rowIdx < layout.length; rowIdx++) {
                const row = layout[rowIdx];
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
                    const char = row[colIdx];
                    if (chars.includes(char)) {
                        const kx = ((colIdx + 0.5) / 10) * 2 - 1;  // Convert [0,1] to [-1,1]
                        const ky = ((rowIdx + 0.5) / 3) * 2 - 1;   // Convert [0,1] to [-1,1]
                        charToPos[char] = [kx, ky];
                    }
                }
            }

            // Calculate start time for relative time normalization
            const traceStartTime = features.path.length > 0 ? (features.path[0].t || 0) : 0;

            for (let idx = 0; idx < T; idx++) {
                const curr = features.path[idx];

                // Basic position features - Convert from [0,1] to [-1,1] for training match
                const x = ((curr.x || 0) * 2) - 1;  // Convert [0,1] to [-1,1]
                const y = ((curr.y || 0) * 2) - 1;  // Convert [0,1] to [-1,1]
                const t = ((curr.t || idx * 10) - traceStartTime) / 1000.0;  // RELATIVE time in seconds from start

                // Velocity features - EXACT match to training code
                let vx = 0, vy = 0, speed = 0;
                if (idx > 0) {
                    const prev = features.path[idx - 1];
                    const currTime = curr.t || idx * 10;
                    const prevTime = prev.t || (idx-1) * 10;
                    const dt = Math.max((currTime - prevTime) / 1000.0, 0.001);
                    vx = (x - (prev.x || 0)) / dt;
                    vy = (y - (prev.y || 0)) / dt;
                    speed = Math.sqrt(vx*vx + vy*vy);
                }

                // Acceleration features - EXACT match to training code
                let ax = 0, ay = 0, acc = 0;
                if (idx > 1) {
                    const prev = features.path[idx - 1];
                    const prev2 = features.path[idx - 2];
                    const currTime = curr.t || idx * 10;
                    const prevTime = prev.t || (idx-1) * 10;
                    const prev2Time = prev2.t || (idx-2) * 10;
                    const dt1 = Math.max((currTime - prevTime) / 1000.0, 0.001);
                    const dt2 = Math.max((prevTime - prev2Time) / 1000.0, 0.001);

                    const vx_prev = ((prev.x || 0) - (prev2.x || 0)) / dt2;
                    const vy_prev = ((prev.y || 0) - (prev2.y || 0)) / dt2;

                    ax = (vx - vx_prev) / dt1;
                    ay = (vy - vy_prev) / dt1;
                    acc = Math.sqrt(ax*ax + ay*ay);
                }

                // Direction features - EXACT match to training code
                let angle = 0, angle_sin = 0, angle_cos = 0;
                if (idx > 0) {
                    angle = Math.atan2(vy, vx);
                    angle_sin = Math.sin(angle);
                    angle_cos = Math.cos(angle);
                }

                // Curvature (change in angle) - EXACT match to training code
                let curvature = 0;
                if (idx > 1) {
                    const prev = features.path[idx - 1];
                    const prev2 = features.path[idx - 2];
                    const angle_prev = Math.atan2((prev.y || 0) - (prev2.y || 0), (prev.x || 0) - (prev2.x || 0));
                    curvature = angle - angle_prev;
                    // Normalize to [-pi, pi] - EXACT match to training code
                    while (curvature > Math.PI) curvature -= 2 * Math.PI;
                    while (curvature < -Math.PI) curvature += 2 * Math.PI;
                }

                // Distance to nearest keys (top 5) - EXACT match to training code
                const key_distances = [];
                for (const [char, [kx, ky]] of Object.entries(charToPos)) {
                    const dist = Math.sqrt((x - kx)**2 + (y - ky)**2);
                    key_distances.push(dist);
                }
                key_distances.sort((a, b) => a - b);
                const top5Distances = key_distances.slice(0, 5);
                while (top5Distances.length < 5) {
                    top5Distances.push(1.0);  // Max distance as padding
                }

                // Segment features - EXACT match to training code
                const total_points = T;
                const progress = idx / Math.max(total_points - 1, 1);  // Position in trace [0, 1]

                // Start/end indicators - EXACT match to training code
                const is_start = idx === 0 ? 1.0 : 0.0;
                const is_end = idx === total_points - 1 ? 1.0 : 0.0;

                // Compile features list - EXACT match to training code structure
                const featList = [
                    x, y, t,                          // Position and time (3)
                    vx, vy, speed,                    // Velocity (3)
                    ax, ay, acc,                      // Acceleration (3)
                    angle, angle_sin, angle_cos,      // Direction (3)
                    curvature,                        // Curvature (1)
                    ...top5Distances,                 // Nearest keys (5)
                    progress,                         // Progress (1)
                    is_start, is_end,                 // Indicators (2)
                ];

                // Add statistical features from window - EXACT match to training code
                const window_size = 5;
                const window_start = Math.max(0, idx - Math.floor(window_size / 2));
                const window_end = Math.min(T, idx + Math.floor(window_size / 2) + 1);
                const window_points = features.path.slice(window_start, window_end);

                if (window_points.length > 1) {
                    const window_x = window_points.map(p => p.x || 0);
                    const window_y = window_points.map(p => p.y || 0);

                    const mean_x = window_x.reduce((a, b) => a + b, 0) / window_x.length;
                    const mean_y = window_y.reduce((a, b) => a + b, 0) / window_y.length;
                    const std_x = Math.sqrt(window_x.map(wx => (wx - mean_x)**2).reduce((a, b) => a + b, 0) / window_x.length);
                    const std_y = Math.sqrt(window_y.map(wy => (wy - mean_y)**2).reduce((a, b) => a + b, 0) / window_y.length);
                    const range_x = Math.max(...window_x) - Math.min(...window_x);
                    const range_y = Math.max(...window_y) - Math.min(...window_y);

                    featList.push(mean_x, std_x, mean_y, std_y, range_x, range_y);
                } else {
                    featList.push(x, 0, y, 0, 0, 0);  // Use current point with no variance
                }

                // Add padding features to reach target dimension - EXACT match to training code
                while (featList.length < 37) {
                    featList.push(0.0);
                }

                // Ensure exactly 37 features - EXACT match to training code
                const features37 = featList.slice(0, 37);

                // Copy to BFT tensor [1, F=37, T] - correct indexing
                for (let f = 0; f < 37; f++) {
                    featuresBFT[f * T + idx] = features37[f];
                }
            }

            console.log(`Running RNNT beam search with features [1, ${F}, ${T}]`);

            // Validate all required components before inference
            if (!encoderSession) throw new Error('Encoder session not loaded');
            if (!decoderSession) throw new Error('Decoder/step session not loaded');
            if (!runtimeMeta) throw new Error('Runtime metadata not loaded');
            if (!wordList || wordList.length === 0) throw new Error('Word list not loaded');
            if (!trieRoot) throw new Error('Trie not built');

            console.log('âœ… All components validated, starting beam search...');

            // Run RNNT word beam search with optimized parameters for speed
            const results = await rnntWordBeam(
                encoderSession,
                decoderSession,
                featuresBFT,
                F, T,
                2,    // L (LSTM layers)
                320,  // H (hidden size)
                null, // D (will be determined from encoder output)
                runtimeMeta,
                wordList,
                trieRoot,
                wordLogPrior, // Pass calculated word frequency priors
                {
                    beamSize: 16,    // Increased for more diversity
                    prunePerBeam: 8, // Increased to explore more candidates
                    maxSymbols: 15,  // Keep reasonable for speed
                    lmLambda: 0.4,   // Increased from 0.1 to give dictionary more weight
                    topK: 5
                }
            );

            const endTime = performance.now();
            const latency = endTime - startTime;

            console.log(`ðŸš€ RNNT inference completed in ${latency.toFixed(1)}ms`);
            console.log('RNNT beam search results:', results);

            if (results.length > 0) {
                const topWord = results[0].word;
                console.log(`âš¡ Top prediction: "${topWord}" (${latency.toFixed(1)}ms latency)`);

                // Performance targets
                if (latency < 500) {
                    console.log('ðŸŽ¯ EXCELLENT: Sub-500ms latency achieved!');
                } else if (latency < 1000) {
                    console.log('âœ… GOOD: Sub-1s latency achieved!');
                } else {
                    console.warn('âš ï¸ SLOW: >1s latency - optimization needed');
                }
            }

            // Convert results to expected format
            return results.map(r => r.word);
        }
        
        
        function displayPredictions(predictions) {
            const suggestionsDiv = document.getElementById('suggestions');
            suggestionsDiv.innerHTML = '';
            
            console.log('Raw predictions from model:', predictions);
            
            // Apply vocabulary filtering if vocab is loaded
            let filteredPredictions = [];
            
            if (swipeVocabulary && swipeVocabulary.isLoaded) {
                console.log('Vocabulary loaded, applying intelligent filtering with custom dictionary support...');
                
                // First, check for 2-character words if it's a straight line
                if (swipePath && swipePath.length > 0 && isNearlyStraightLine(swipePath)) {
                    const twoCharWord = getTwoCharWordFromSwipe(keySequence);
                    if (twoCharWord) {
                        // Add valid 2-char word to the beginning of predictions
                        filteredPredictions.push(twoCharWord);
                    }
                }
                
                // Convert predictions to format expected by SwipeVocabulary
                const nnPredictions = predictions.map((word, index) => ({
                    word: word,
                    confidence: 1.0 - (index * 0.1) // Assign decreasing confidence based on order
                }));
                
                // Calculate swipe statistics
                const swipeStats = {
                    pathLength: swipePath ? swipePath.length : 0,
                    expectedLength: keySequence ? Math.round(keySequence.length * 0.8) : 0
                };
                
                // Use SwipeVocabulary's intelligent filtering (which now includes custom dictionary support)
                const filtered = swipeVocabulary.filterPredictions(nnPredictions, swipeStats);
                
                // Extract words from filtered results and mark sources
                filtered.forEach(result => {
                    if (!filteredPredictions.includes(result.word)) {
                        filteredPredictions.push(result.word);
                        
                        // Log custom/personal word boost for debugging
                        if (result.source === 'personal') {
                            console.log(`ðŸŽ¯ Personal word boosted: ${result.word} (score: ${result.score.toFixed(4)})`);
                        } else if (dictionaryManager && dictionaryManager.personalWords.has(result.word)) {
                            console.log(`ðŸ“š Custom word found: ${result.word}`);
                        }
                    }
                });
                
                // Limit to top predictions but ensure we have at least 5
                filteredPredictions = filteredPredictions.slice(0, 10); // Get more initially
                console.log('Filtered predictions (with custom dictionary):', filteredPredictions);
            } else {
                console.warn('Vocabulary not loaded! Filtering with basic validation.');
                // Fallback: only show predictions that look like valid English words
                const validPredictions = predictions
                    .filter(word => word && word.match(/^[a-zA-Z]+$/) && word.length >= 2 && word.length <= 35)
                    .map(word => word.toLowerCase())
                    .filter(word => !filteredPredictions.includes(word));
                filteredPredictions.push(...validPredictions);
            }
            
            // Ensure we always have at least 5 suggestions by adding raw predictions if needed
            if (filteredPredictions.length < 5) {
                console.log(`Only ${filteredPredictions.length} filtered predictions, adding raw predictions to reach 5`);
                
                // Add raw predictions that aren't already included
                const additionalPredictions = predictions
                    .map(word => word.toLowerCase().trim())
                    .filter(word => word && word.match(/^[a-z]+$/) && !filteredPredictions.includes(word))
                    .slice(0, 5 - filteredPredictions.length);
                
                additionalPredictions.forEach(word => console.log(`Added raw prediction: ${word}`));
                filteredPredictions.push(...additionalPredictions);
                
                // If still not enough, add common 2-char words based on keySequence
                if (filteredPredictions.length < 5 && keySequence && keySequence.length >= 2) {
                    const startKey = keySequence[0]?.key;
                    const endKey = keySequence[keySequence.length - 1]?.key;
                    
                    if (startKey && endKey && commonTwoCharWords) {
                        for (const twoCharWord of commonTwoCharWords) {
                            if (filteredPredictions.length >= 5) break;
                            
                            if ((twoCharWord.startsWith(startKey) || twoCharWord.endsWith(endKey)) && 
                                !filteredPredictions.includes(twoCharWord)) {
                                filteredPredictions.push(twoCharWord);
                                console.log(`Added 2-char fallback: ${twoCharWord}`);
                            }
                        }
                    }
                }
            }
            
            // Final limit to exactly 5 suggestions
            filteredPredictions = filteredPredictions.slice(0, 5);
            console.log(`Final predictions count: ${filteredPredictions.length}`, filteredPredictions);
            
            // Update prediction state
            currentPredictions = [...filteredPredictions];
            hasPendingPredictions = filteredPredictions.length > 0;
            userMadeManualSelection = false;
            
            filteredPredictions.forEach((word, index) => {
                const suggestion = document.createElement('div');
                
                // Check if this is a custom/personal word for special styling
                const isPersonalWord = dictionaryManager && dictionaryManager.personalWords.has(word);
                const isCustomWord = dictionaryManager && (dictionaryManager.customWords.has(word) || dictionaryManager.androidDictionary.has(word));
                
                let className;
                if (index === 0) {
                    // Top prediction
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-neon-blue/20 to-neon-purple/20 border border-neon-blue/50 text-white text-sm cursor-pointer hover:scale-105 transition-transform';
                } else if (isPersonalWord) {
                    // Personal dictionary words get a special highlight
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-neon-pink/15 to-neon-purple/15 border border-neon-pink/40 text-white text-sm cursor-pointer hover:bg-gradient-to-r hover:from-neon-pink/25 hover:to-neon-purple/25 transition-all';
                } else if (isCustomWord) {
                    // Custom dictionary words get a different highlight
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-green-500/15 to-blue-500/15 border border-green-500/40 text-gray-200 text-sm cursor-pointer hover:bg-gradient-to-r hover:from-green-500/25 hover:to-blue-500/25 transition-all';
                } else {
                    // Regular vocabulary words
                    className = 'px-4 py-1.5 rounded-full bg-white/5 border border-white/20 text-gray-300 text-sm cursor-pointer hover:bg-white/10 transition-all';
                }
                
                suggestion.className = className;
                
                // Add indicator for custom words
                if (isPersonalWord) {
                    suggestion.textContent = `â˜… ${word}`; // Star for personal words
                } else if (isCustomWord) {
                    suggestion.textContent = `+ ${word}`; // Plus for custom words
                } else {
                    suggestion.textContent = word;
                }
                
                suggestion.onclick = () => selectWord(word);
                suggestionsDiv.appendChild(suggestion);
            });
        }
        
        function selectWord(word) {
            // Mark that user made manual selection
            userMadeManualSelection = true;
            
            inputText += word + ' ';
            document.getElementById('inputText').textContent = inputText;
            
            // Clear prediction state and swipe canvas, but keep the input text
            clearPredictionState();
            clearSwipeState();
            
            console.log(`ðŸ‘† User selected swipe prediction: "${word}"`);
        }
        
        function handleBackspace() {
            if (currentTypedWord.length > 0) {
                // Remove character from current typed word
                currentTypedWord = currentTypedWord.slice(0, -1);
                
                // Update display
                const words = inputText.split(' ');
                if (currentTypedWord.length > 0) {
                    words[words.length - 1] = currentTypedWord;
                    document.getElementById('inputText').textContent = words.join(' ');
                    generateTapPredictions(currentTypedWord);
                } else {
                    // If no more characters in current word, remove the word
                    words.pop();
                    inputText = words.join(' ') + (words.length > 0 ? ' ' : '');
                    document.getElementById('inputText').textContent = inputText;
                    clearTapPredictions();
                }
            } else if (inputText.length > 0) {
                // Remove character from inputText
                inputText = inputText.slice(0, -1);
                document.getElementById('inputText').textContent = inputText;
                clearTapPredictions();
            }
        }
        
        function handleSpace() {
            // Auto-select top prediction if available and not manually selected
            if (hasPendingPredictions && !userMadeManualSelection && currentPredictions.length > 0) {
                autoSelectTopPrediction();
                return; // Space is consumed by auto-selection
            }
            
            if (currentTypedWord.length > 0) {
                // Finalize current typed word
                inputText = document.getElementById('inputText').textContent + ' ';
                document.getElementById('inputText').textContent = inputText;
                currentTypedWord = '';
                clearTapPredictions();
            } else {
                // Add space to existing text
                inputText += ' ';
                document.getElementById('inputText').textContent = inputText;
            }
        }
        
        function clearInput() {
            cleanupGestureState();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clearPredictionState(); // Use the comprehensive clear function
            inputText = '';
            document.getElementById('inputText').textContent = '';
            document.getElementById('debugOutput').classList.add('hidden');
        }
        
        function clearSwipeState() {
            // Clear swipe-related state without clearing input text
            cleanupGestureState();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('debugOutput').classList.add('hidden');
        }
        
        function clearTapPredictions() {
            // Reset prediction state when clearing manually
            currentPredictions = [];
            hasPendingPredictions = false;
            userMadeManualSelection = false;
            document.getElementById('suggestions').innerHTML = '<div class="text-gray-500 text-sm">Tap or swipe on the keyboard to begin</div>';
        }
        
        function toggleDebug() {
            DEBUG.enabled = !DEBUG.enabled;
            document.getElementById('debugStatus').textContent = DEBUG.enabled ? 'ON' : 'OFF';
            document.getElementById('debugOverlay').classList.toggle('hidden', !DEBUG.enabled);
            
            if (!DEBUG.enabled) {
                document.getElementById('coordinateDisplay').classList.add('hidden');
                document.getElementById('debugOutput').classList.add('hidden');
            }
        }
        
        // Dictionary Management Functions
        let dictionaryManager = null;
        
        // Initialize custom dictionary integration with the main vocabulary
        function initializeCustomDictionaryIntegration() {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) {
                console.warn('Cannot initialize custom dictionary - vocabulary not loaded');
                return;
            }
            
            // Initialize the custom dictionary manager
            if (typeof CustomDictionaryManager !== 'undefined') {
                dictionaryManager = new CustomDictionaryManager(swipeVocabulary);
                
                // The CustomDictionaryManager constructor automatically loads from localStorage
                // and calls mergeIntoVocabulary(), so custom words are already integrated
                
                console.log('Custom dictionary integration initialized');
                console.log('Custom dictionary stats:', dictionaryManager.getStats());
            } else {
                console.warn('CustomDictionaryManager not loaded');
            }
        }
        
        // Update vocabulary with new custom word (reactive update)
        function updateVocabularyWithCustomWord(word, frequency = 1e-5) {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) {
                console.warn('Vocabulary not ready for custom word updates');
                return false;
            }
            
            const cleanWord = word.toLowerCase().trim();
            if (!cleanWord || !cleanWord.match(/^[a-z]+$/)) {
                return false;
            }
            
            // Add word to main vocabulary with boost for custom words
            const boostFactor = 1.5;
            const existingFreq = swipeVocabulary.wordFreq.get(cleanWord) || 0;
            const newFreq = Math.max(existingFreq, frequency * boostFactor);
            
            swipeVocabulary.wordFreq.set(cleanWord, newFreq);
            
            // Add to common words if frequency is high enough
            if (newFreq > 1e-5) {
                swipeVocabulary.commonWords.add(cleanWord);
            }
            
            // Update top5000 if needed
            if (newFreq > 1e-6) {
                swipeVocabulary.top5000.add(cleanWord);
            }
            
            // Update words by length structure if it exists
            if (swipeVocabulary.wordsByLength) {
                const length = cleanWord.length;
                if (!swipeVocabulary.wordsByLength.has(length)) {
                    swipeVocabulary.wordsByLength.set(length, []);
                }
                const wordsAtLength = swipeVocabulary.wordsByLength.get(length);
                if (!wordsAtLength.some(item => (item.word || item) === cleanWord)) {
                    wordsAtLength.push({ word: cleanWord, frequency: newFreq });
                    // Keep sorted by frequency
                    wordsAtLength.sort((a, b) => (b.frequency || 0) - (a.frequency || 0));
                }
            }
            
            console.log(`Updated vocabulary with custom word: ${cleanWord} (freq: ${newFreq})`);
            return true;
        }
        
        function initializeDictionary() {
            if (swipeVocabulary && swipeVocabulary.isLoaded) {
                dictionaryManager = new CustomDictionaryManager(swipeVocabulary);
                updateDictionaryStats();
            }
        }
        
        function toggleDictionary() {
            const panel = document.getElementById('dictionaryPanel');
            panel.classList.toggle('hidden');
            
            if (!panel.classList.contains('hidden')) {
                if (!dictionaryManager) {
                    initializeDictionary();
                }
                updateDictionaryStats();
                updatePersonalWordsList();
            }
        }
        
        function updateDictionaryStats() {
            if (!dictionaryManager) return;
            
            document.getElementById('baseDictSize').textContent = swipeVocabulary.wordFreq.size.toLocaleString();
            document.getElementById('customDictSize').textContent = dictionaryManager.customWords.size.toLocaleString();
            document.getElementById('personalDictSize').textContent = dictionaryManager.personalWords.size.toLocaleString();
            
            const total = swipeVocabulary.wordFreq.size + dictionaryManager.customWords.size + dictionaryManager.personalWords.size;
            document.getElementById('totalDictSize').textContent = total.toLocaleString();
        }
        
        function updatePersonalWordsList() {
            if (!dictionaryManager) return;
            
            const listDiv = document.getElementById('personalWordsList');
            listDiv.innerHTML = '';
            
            const words = Array.from(dictionaryManager.personalWords).sort();
            words.forEach(word => {
                const wordDiv = document.createElement('div');
                wordDiv.className = 'flex justify-between items-center px-2 py-1 bg-white/5 rounded hover:bg-white/10 transition-colors';
                wordDiv.innerHTML = `
                    <span class="text-gray-300">${word}</span>
                    <button onclick="removePersonalWord('${word}')" 
                            class="text-red-400 hover:text-red-300 text-xs">âœ•</button>
                `;
                listDiv.appendChild(wordDiv);
            });
            
            if (words.length === 0) {
                listDiv.innerHTML = '<div class="text-gray-500 text-sm">No personal words added yet</div>';
            }
        }
        
        function importCustomWords() {
            if (!dictionaryManager) {
                initializeCustomDictionaryIntegration();
            }
            
            const fileInput = document.getElementById('dictionaryFile');
            const textArea = document.getElementById('customWordList');
            
            // Handle file upload
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    // Import to custom dictionary manager
                    const imported = dictionaryManager.importCustomWordList(content);
                    
                    // Immediately update main vocabulary for each imported word
                    const words = content.split(/[\n,;]+/);
                    words.forEach(word => {
                        const clean = word.toLowerCase().trim();
                        if (clean && clean.match(/^[a-z]+$/) && clean.length >= 2) {
                            updateVocabularyWithCustomWord(clean, 5e-6);
                        }
                    });
                    
                    alert(`Successfully imported ${imported} words from file!`);
                    updateDictionaryStats();
                    fileInput.value = '';
                    
                    console.log(`Imported ${imported} custom words - ready for predictions!`);
                };
                
                reader.readAsText(file);
            } 
            // Handle text area input
            else if (textArea.value.trim()) {
                const content = textArea.value.trim();
                
                // Import to custom dictionary manager
                const imported = dictionaryManager.importCustomWordList(content);
                
                // Immediately update main vocabulary for each imported word
                const words = content.split(/[\n,;]+/);
                words.forEach(word => {
                    const clean = word.toLowerCase().trim();
                    if (clean && clean.match(/^[a-z]+$/) && clean.length >= 2) {
                        updateVocabularyWithCustomWord(clean, 5e-6);
                    }
                });
                
                alert(`Successfully imported ${imported} words!`);
                updateDictionaryStats();
                textArea.value = '';
                
                console.log(`Imported ${imported} custom words - ready for predictions!`);
            } else {
                alert('Please select a file or enter words to import');
            }
        }
        
        function addPersonalWord() {
            if (!dictionaryManager) {
                initializeCustomDictionaryIntegration();
            }
            
            const input = document.getElementById('newWord');
            const word = input.value.toLowerCase().trim();
            
            if (word && word.match(/^[a-z]+$/)) {
                // Add to custom dictionary manager (this now checks for duplicates)
                const added = dictionaryManager.addPersonalWord(word);
                
                if (added) {
                    // Immediately update the main vocabulary for reactive behavior
                    updateVocabularyWithCustomWord(word, 8e-6); // Higher frequency for personal words
                    
                    updateDictionaryStats();
                    updatePersonalWordsList();
                    input.value = '';
                    
                    console.log(`Added personal word "${word}" - ready for predictions!`);
                } else {
                    alert(`The word "${word}" already exists in the main vocabulary`);
                    input.value = '';
                }
            } else {
                alert('Please enter a valid word (letters only)');
            }
        }
        
        function removePersonalWord(word) {
            if (dictionaryManager) {
                dictionaryManager.removePersonalWord(word);
                updateDictionaryStats();
                updatePersonalWordsList();
            }
        }
        
        function exportDictionary() {
            if (!dictionaryManager) return;
            
            const data = dictionaryManager.exportAll();
            const blob = new Blob([data], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'custom-dictionary.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearCustomDictionary() {
            if (!dictionaryManager) return;
            
            if (confirm('Are you sure you want to clear all custom and personal words?')) {
                dictionaryManager.clearAll();
                updateDictionaryStats();
                updatePersonalWordsList();
                alert('Custom dictionary cleared!');
            }
        }
        
        async function loadNicheWords() {
            if (!dictionaryManager) {
                initializeCustomDictionaryIntegration();
            }
            
            try {
                // Get all niche words from the loader
                const allNicheWords = getAllNicheWords();
                
                // Import to custom dictionary manager
                const imported = dictionaryManager.importCustomWordList(allNicheWords.join('\n'));
                
                // Immediately update main vocabulary for each niche word
                allNicheWords.forEach(word => {
                    const clean = word.toLowerCase().trim();
                    if (clean && clean.match(/^[a-z]+$/) && clean.length >= 2) {
                        updateVocabularyWithCustomWord(clean, 3e-6); // Medium frequency for niche words
                    }
                });
                
                console.log(`Imported ${imported} niche words - ready for predictions!`);
                alert(`Successfully imported ${imported} niche words!`);
                updateDictionaryStats();
            } catch (error) {
                console.error('Error loading niche words:', error);
                alert('Error loading niche words. Check console for details.');
            }
        }
        
        function updateDebugDisplay(coords, key) {
            document.getElementById('xCoord').textContent = coords.x;
            document.getElementById('yCoord').textContent = coords.y;
            document.getElementById('normCoords').textContent = `${coords.normalized.x}, ${coords.normalized.y}`;
            document.getElementById('currentKeyDebug').textContent = key || '-';
            document.getElementById('pathLength').textContent = swipePath.length;
            document.getElementById('keysTouched').textContent = keySequence.map(k => k.key).join('');
        }
        
        function displaySwipeOutput(data) {
            const output = document.getElementById('debugOutput');
            const text = document.getElementById('debugText');
            
            output.classList.remove('hidden');
            text.textContent = JSON.stringify({
                keySequence: data.keySequence.map(k => ({
                    key: k.key,
                    index: k.index,
                    time: k.timestamp - data.path[0].timestamp
                })),
                pathSample: data.path.filter((_, i) => i % 5 === 0).map(p => ({
                    x: p.x,
                    y: p.y,
                    norm: p.normalized,
                    key: p.key
                })),
                duration: data.duration,
                pointCount: data.path.length
            }, null, 2);
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', startSwipe);
        canvas.addEventListener('mousemove', continueSwipe);
        canvas.addEventListener('mouseup', endSwipe);
        canvas.addEventListener('mouseleave', endSwipe);
        
        canvas.addEventListener('touchstart', startSwipe, { passive: false });
        canvas.addEventListener('touchmove', continueSwipe, { passive: false });
        canvas.addEventListener('touchend', endSwipe, { passive: false });
        canvas.addEventListener('touchcancel', endSwipe, { passive: false });
        
        // Current typing context for tap predictions
        let currentTypedWord = '';
        
        // Prediction state tracking
        let currentPredictions = [];
        let hasPendingPredictions = false;
        let userMadeManualSelection = false;
        
        // Clean up gesture state
        function cleanupGestureState() {
            isDrawing = false;
            isPotentialSwipe = false;
            swipePath = [];
            keySequence = [];
            currentKey = null;
            swipeStartPos = null;
            swipeStartTime = null;
            
            if (tapTimeout) {
                clearTimeout(tapTimeout);
                tapTimeout = null;
            }
            
            // Clear highlights
            document.querySelectorAll('.key-active').forEach(key => {
                key.classList.remove('key-active');
            });
        }
        
        // Enhanced tap handling with predictions
        function handleKeyTap(keyValue) {
            // Auto-select top prediction if user starts new input without manual selection
            if (hasPendingPredictions && !userMadeManualSelection && currentPredictions.length > 0) {
                autoSelectTopPrediction();
            }
            
            if (keyValue && keyValue.length === 1 && keyValue.match(/[a-z]/i)) {
                // Add character to current typed word
                currentTypedWord += keyValue.toLowerCase();
                
                // Update input display to show what's being typed
                const currentInput = document.getElementById('inputText').textContent;
                const words = currentInput.split(' ');
                words[words.length - 1] = currentTypedWord;
                document.getElementById('inputText').textContent = words.join(' ');
                
                console.log(`Typing: "${currentTypedWord}"`);
                
                // Generate predictions for the current typed word
                generateTapPredictions(currentTypedWord);
                
            } else {
                // Handle special keys
                console.log('Special key tapped:', keyValue);
                
                switch (keyValue) {
                    case 'backspace':
                        handleBackspace();
                        break;
                    case 'space':
                        handleSpace();
                        break;
                    case 'shift':
                        // TODO: Handle shift functionality
                        break;
                    default:
                        console.log(`Unhandled special key: ${keyValue}`);
                }
            }
        }
        
        // Generate predictions for tap-typed words
        function generateTapPredictions(typedWord) {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) {
                console.warn('Vocabulary not loaded for tap predictions');
                return;
            }
            
            console.log(`Generating tap predictions for: "${typedWord}"`);
            
            let predictions = [];
            
            // Strategy 1: Exact matches and completions
            if (typedWord.length >= 1) {
                // Find words that start with typed characters
                const completions = findWordCompletions(typedWord);
                predictions.push(...completions);
            }
            
            // Strategy 2: Common single character words
            if (typedWord.length === 1) {
                const singleCharWords = getSingleCharacterWords(typedWord);
                predictions.push(...singleCharWords);
            }
            
            // Strategy 3: Fuzzy matches for typos
            if (typedWord.length >= 2) {
                const fuzzyMatches = findFuzzyMatches(typedWord);
                predictions.push(...fuzzyMatches);
            }
            
            // Remove duplicates and limit to 5
            predictions = [...new Set(predictions)].slice(0, 5);
            
            // Ensure we always have the typed word as first option if it's valid
            if (typedWord.length >= 1) {
                predictions = [typedWord, ...predictions.filter(p => p !== typedWord)].slice(0, 5);
            }
            
            console.log('Tap predictions:', predictions);
            
            // Update prediction state for tap predictions  
            currentPredictions = [...predictions];
            hasPendingPredictions = predictions.length > 0;
            userMadeManualSelection = false;
            
            displayTapPredictions(predictions, typedWord);
        }
        
        // Find word completions that start with typed text
        function findWordCompletions(prefix) {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) return [];
            
            const completions = [];
            const prefixLower = prefix.toLowerCase();
            
            // Check common words first
            for (const word of swipeVocabulary.commonWords) {
                if (word.startsWith(prefixLower) && word !== prefixLower) {
                    completions.push(word);
                    if (completions.length >= 10) break;
                }
            }
            
            // Check top5000 if we need more
            if (completions.length < 10) {
                for (const word of swipeVocabulary.top5000) {
                    if (word.startsWith(prefixLower) && word !== prefixLower && !completions.includes(word)) {
                        completions.push(word);
                        if (completions.length >= 10) break;
                    }
                }
            }
            
            // Sort by frequency
            completions.sort((a, b) => {
                const freqA = swipeVocabulary.getWordFrequency(a);
                const freqB = swipeVocabulary.getWordFrequency(b);
                return freqB - freqA;
            });
            
            return completions.slice(0, 5);
        }
        
        // Get valid single character words
        function getSingleCharacterWords(char) {
            const singleCharWords = ['a', 'i']; // Valid single character words in English
            const charLower = char.toLowerCase();
            
            // Include the character itself if it's a valid word
            if (singleCharWords.includes(charLower)) {
                return [charLower];
            }
            
            // For other characters, suggest words that start with that character
            const suggestions = [];
            const startingWords = ['an', 'at', 'as', 'am', 'is', 'it', 'in', 'of', 'on', 'or', 'up', 'us'];
            
            for (const word of startingWords) {
                if (word.startsWith(charLower)) {
                    suggestions.push(word);
                }
            }
            
            return suggestions.slice(0, 3);
        }
        
        // Find fuzzy matches for potential typos
        function findFuzzyMatches(typedWord) {
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) return [];
            
            const matches = [];
            const typedLower = typedWord.toLowerCase();
            
            // Check words of similar length (Â±1)
            const targetLength = typedWord.length;
            
            // Sample from common words to avoid performance issues
            const wordsToCheck = Array.from(swipeVocabulary.commonWords).slice(0, 200);
            
            for (const word of wordsToCheck) {
                if (Math.abs(word.length - targetLength) <= 1) {
                    const distance = levenshteinDistance(typedLower, word);
                    if (distance <= 1 && word !== typedLower) { // Allow 1 edit distance
                        matches.push({ word, distance, frequency: swipeVocabulary.getWordFrequency(word) });
                    }
                }
            }
            
            // Sort by distance, then frequency
            matches.sort((a, b) => {
                if (a.distance !== b.distance) return a.distance - b.distance;
                return b.frequency - a.frequency;
            });
            
            return matches.slice(0, 3).map(m => m.word);
        }
        
        // Display tap predictions in the UI
        function displayTapPredictions(predictions, typedWord) {
            const suggestionsDiv = document.getElementById('suggestions');
            suggestionsDiv.innerHTML = '';
            
            if (predictions.length === 0) {
                suggestionsDiv.innerHTML = '<div class="text-gray-500 text-sm">No predictions</div>';
                return;
            }
            
            predictions.forEach((word, index) => {
                const suggestion = document.createElement('div');
                
                // Check if this is a custom/personal word for special styling
                const isPersonalWord = dictionaryManager && dictionaryManager.personalWords.has(word);
                const isCustomWord = dictionaryManager && (dictionaryManager.customWords.has(word) || dictionaryManager.androidDictionary.has(word));
                const isTypedWord = word === typedWord;
                
                let className;
                if (isTypedWord) {
                    // Currently typed word - special styling
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-yellow-500/20 to-orange-500/20 border border-yellow-500/50 text-white text-sm cursor-pointer hover:scale-105 transition-transform';
                } else if (index === 0 || (index === 1 && isTypedWord)) {
                    // Top prediction (or second if first is typed word)
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-neon-blue/20 to-neon-purple/20 border border-neon-blue/50 text-white text-sm cursor-pointer hover:scale-105 transition-transform';
                } else if (isPersonalWord) {
                    // Personal dictionary words
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-neon-pink/15 to-neon-purple/15 border border-neon-pink/40 text-white text-sm cursor-pointer hover:bg-gradient-to-r hover:from-neon-pink/25 hover:to-neon-purple/25 transition-all';
                } else if (isCustomWord) {
                    // Custom dictionary words
                    className = 'px-4 py-1.5 rounded-full bg-gradient-to-r from-green-500/15 to-blue-500/15 border border-green-500/40 text-gray-200 text-sm cursor-pointer hover:bg-gradient-to-r hover:from-green-500/25 hover:to-blue-500/25 transition-all';
                } else {
                    // Regular predictions
                    className = 'px-4 py-1.5 rounded-full bg-white/5 border border-white/20 text-gray-300 text-sm cursor-pointer hover:bg-white/10 transition-all';
                }
                
                suggestion.className = className;
                
                // Add indicators for special word types
                if (isTypedWord) {
                    suggestion.textContent = `"${word}"`; // Quotes for currently typed word
                } else if (isPersonalWord) {
                    suggestion.textContent = `â˜… ${word}`;
                } else if (isCustomWord) {
                    suggestion.textContent = `+ ${word}`;
                } else {
                    suggestion.textContent = word;
                }
                
                suggestion.onclick = () => selectTapWord(word);
                suggestionsDiv.appendChild(suggestion);
            });
        }
        
        // Auto-select the top prediction
        function autoSelectTopPrediction() {
            if (currentPredictions.length === 0) return;
            
            const topPrediction = currentPredictions[0];
            console.log(`ðŸ¤– Auto-selecting top prediction: "${topPrediction}"`);
            
            // Add the top prediction to input with space
            inputText += topPrediction + ' ';
            document.getElementById('inputText').textContent = inputText;
            
            // Clear prediction state
            clearPredictionState();
        }
        
        // Clear prediction state
        function clearPredictionState() {
            currentPredictions = [];
            hasPendingPredictions = false;
            userMadeManualSelection = false;
            currentTypedWord = '';
            document.getElementById('suggestions').innerHTML = '<div class="text-gray-500 text-sm">Tap or swipe on the keyboard to begin</div>';
        }
        
        // Handle word selection from tap predictions
        function selectTapWord(word) {
            // Mark that user made manual selection
            userMadeManualSelection = true;
            
            // Replace the current typed word with selected word
            const currentInput = document.getElementById('inputText').textContent;
            const words = currentInput.split(' ');
            words[words.length - 1] = word;
            inputText = words.join(' ') + ' ';
            
            document.getElementById('inputText').textContent = inputText;
            
            // Clear prediction state completely after manual selection
            clearPredictionState();
            
            console.log(`ðŸ‘† User selected: "${word}"`);
        }
        
        // Prevent scrolling
        document.getElementById('keyboard').addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        
        // Debug function to test custom dictionary functionality
        function testCustomDictionary() {
            console.log('=== Testing Custom Dictionary Integration ===');
            
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) {
                console.error('âŒ Vocabulary not loaded');
                return false;
            }
            
            if (!dictionaryManager) {
                console.error('âŒ Dictionary manager not initialized');
                return false;
            }
            
            // Test 1: Add a test word
            const testWord = 'testword';
            console.log(`Adding test word: ${testWord}`);
            dictionaryManager.addPersonalWord(testWord);
            updateVocabularyWithCustomWord(testWord, 8e-6);
            
            // Test 2: Check if word exists in vocabulary
            const hasWord = swipeVocabulary.hasWord(testWord);
            const frequency = swipeVocabulary.getWordFrequency(testWord);
            console.log(`âœ“ Test word "${testWord}" in vocabulary: ${hasWord}, frequency: ${frequency}`);
            
            // Vocabulary system ready for production use
            console.log('âœ“ SwipeVocabulary system initialized and ready');
            return true;
        }
        
        // Test function for tap functionality
        function testTapFunctionality() {
            console.log('=== Testing Tap Functionality ===');
            
            if (!swipeVocabulary || !swipeVocabulary.isLoaded) {
                console.error('âŒ Vocabulary not loaded');
                return false;
            }
            
            // Test 1: Single character word ('a')
            console.log('Test 1: Typing single character "a"');
            currentTypedWord = '';
            handleKeyTap('a');
            console.log(`âœ“ Current typed word: "${currentTypedWord}"`);
            console.log(`âœ“ Input display: "${document.getElementById('inputText').textContent}"`);
            
            // Test 2: Multi-character word completion
            console.log('\nTest 2: Typing "th" for completions');
            currentTypedWord = '';
            handleKeyTap('t');
            handleKeyTap('h');
            console.log(`âœ“ Current typed word: "${currentTypedWord}"`);
            
            // Test 3: Backspace functionality
            console.log('\nTest 3: Testing backspace');
            handleKeyTap('backspace');
            console.log(`âœ“ After backspace: "${currentTypedWord}"`);
            
            // Test 4: Space functionality
            console.log('\nTest 4: Testing space bar');
            handleKeyTap('h'); // Add back the 'h'
            handleKeyTap('space');
            console.log(`âœ“ After space: "${currentTypedWord}" (should be empty)`);
            console.log(`âœ“ Input text: "${document.getElementById('inputText').textContent}"`);
            
            // Test 5: Word completion suggestions
            console.log('\nTest 5: Testing word completions for "he"');
            currentTypedWord = '';
            handleKeyTap('h');
            handleKeyTap('e');
            const completions = findWordCompletions('he');
            console.log(`âœ“ Completions for "he":`, completions);
            
            console.log('=== Tap Functionality Test Complete ===');
            return true;
        }
        
        // Test function for auto-prediction functionality
        function testAutoPrediction() {
            console.log('=== Testing Auto-Prediction Functionality ===');
            
            // Clear everything first
            clearInput();
            
            // Test 1: Create predictions with tap, then start new tap without selection
            console.log('\nTest 1: Tap "t" -> Tap "h" (should auto-select top prediction from "t")');
            currentPredictions = ['test', 'the', 'that']; // Mock predictions
            hasPendingPredictions = true;
            userMadeManualSelection = false;
            
            console.log(`Before second tap - Predictions: [${currentPredictions.join(', ')}]`);
            console.log(`hasPendingPredictions: ${hasPendingPredictions}, userMadeManualSelection: ${userMadeManualSelection}`);
            
            handleKeyTap('h'); // This should auto-select 'test' first
            
            console.log(`After tap - Input text: "${document.getElementById('inputText').textContent}"`);
            console.log(`Predictions state cleared: ${!hasPendingPredictions}`);
            
            // Test 2: Manual selection should not trigger auto-selection
            console.log('\nTest 2: Manual selection should clear auto-selection state');
            currentPredictions = ['hello', 'help', 'her'];
            hasPendingPredictions = true;
            userMadeManualSelection = false;
            
            selectTapWord('hello'); // Manual selection
            
            console.log(`After manual selection - userMadeManualSelection: ${userMadeManualSelection}`);
            console.log(`Input text: "${document.getElementById('inputText').textContent}"`);
            
            // Test 3: Space bar auto-selection
            console.log('\nTest 3: Space bar should auto-select top prediction');
            currentPredictions = ['world', 'work', 'word'];
            hasPendingPredictions = true;
            userMadeManualSelection = false;
            
            handleSpace(); // Should auto-select 'world'
            
            console.log(`After space - Input text: "${document.getElementById('inputText').textContent}"`);
            
            console.log('=== Auto-Prediction Test Complete ===');
            
            // Reset
            clearInput();
        }
        
        // Test function for long word functionality
        function testLongWordSupport() {
            console.log('=== Testing Long Word Support ===');
            
            // Test 1: Verify artificial limits are removed
            console.log('\nTest 1: Testing word length validation');
            const longWords = ['supercalifragilisticexpialidocious', 'antidisestablishmentarianism', 'floccinaucinihilipilification'];
            const shortWords = ['test', 'word', 'hello'];
            
            longWords.forEach(word => {
                const isValid = word && word.match(/^[a-zA-Z]+$/) && word.length >= 2 && word.length <= 35;
                console.log(`"${word}" (${word.length} chars): ${isValid ? 'âœ“ VALID' : 'âŒ REJECTED'}`);
            });
            
            // Test 2: Test swipe vs tap detection
            console.log('\nTest 2: Testing swipe vs tap detection');
            
            // Mock short path (should be TAP)
            const shortPath = [
                {x: 100, y: 100}, {x: 102, y: 101}, {x: 103, y: 102}
            ];
            const shortDistance = getSwipeDistance(shortPath);
            const isShortSwipe = (shortPath.length > 10 || 50 > 100 || 1 > 1 || (shortPath.length > 3 && shortDistance > 30));
            console.log(`Short path: ${shortPath.length} points, ${shortDistance.toFixed(1)}px â†’ ${isShortSwipe ? 'SWIPE' : 'TAP'}`);
            
            // Mock long path (should be SWIPE) 
            const longPath = [];
            for(let i = 0; i < 20; i++) {
                longPath.push({x: 100 + i*10, y: 100 + Math.sin(i/5)*20});
            }
            const longDistance = getSwipeDistance(longPath);
            const isLongSwipe = (longPath.length > 10 || 200 > 100 || 5 > 1 || (longPath.length > 3 && longDistance > 30));
            console.log(`Long path: ${longPath.length} points, ${longDistance.toFixed(1)}px â†’ ${isLongSwipe ? 'SWIPE' : 'TAP'}`);
            
            // Test 3: Check beam search settings
            console.log('\nTest 3: Checking beam search configuration');
            console.log(`Max output length: 35 characters`);
            console.log(`Beam width: 8 (increased from 5)`);
            console.log(`MAX_SEQUENCE_LENGTH: ${MAX_SEQUENCE_LENGTH} (model constraint)`);
            
            console.log('=== Long Word Support Test Complete ===');
        }
        
        // Test function for selection functionality
        function testSelectionFunctionality() {
            console.log('=== Testing Selection Functionality ===');
            
            // Clear everything first
            clearInput();
            
            // Test 1: Test swipe prediction selection
            console.log('\nTest 1: Testing swipe prediction selection');
            inputText = 'Hello world ';
            document.getElementById('inputText').textContent = inputText;
            console.log(`Before swipe selection: "${inputText}"`);
            
            // Mock current predictions
            currentPredictions = ['testing', 'example', 'word'];
            hasPendingPredictions = true;
            userMadeManualSelection = false;
            
            selectWord('testing');
            console.log(`After swipe selection: "${inputText}"`);
            console.log(`Should be: "Hello world testing "`);
            
            // Test 2: Test tap prediction selection
            console.log('\nTest 2: Testing tap prediction selection');
            // Set up typing state
            currentTypedWord = 'exampl';
            const words = inputText.split(' ');
            words[words.length - 1] = currentTypedWord;
            document.getElementById('inputText').textContent = words.join(' ');
            console.log(`Before tap selection: "${document.getElementById('inputText').textContent}"`);
            
            selectTapWord('example');
            console.log(`After tap selection: "${inputText}"`);
            console.log(`Should be: "Hello world testing example "`);
            
            // Test 3: Test auto-selection
            console.log('\nTest 3: Testing auto-selection');
            currentPredictions = ['world', 'work', 'word'];
            hasPendingPredictions = true;
            userMadeManualSelection = false;
            console.log(`Before auto-selection: "${inputText}"`);
            
            autoSelectTopPrediction();
            console.log(`After auto-selection: "${inputText}"`);
            console.log(`Should be: "Hello world testing example world "`);
            
            console.log('=== Selection Functionality Test Complete ===');
            
            // Reset
            clearInput();
        }
        
        // Test function for tap vs swipe detection
        function testGestureDetection() {
            console.log('=== Testing Gesture Detection ===');
            
            // Test 1: Verify key event isolation
            console.log('\nTest 1: Key event isolation');
            console.log('- Added event.stopPropagation() to prevent canvas swipe events');
            console.log('- Added touchstart, touchend, mousedown, mouseup event handlers');
            console.log('- Added { passive: false } for proper touch handling');
            
            // Test 2: Verify swipe detection logic
            console.log('\nTest 2: Swipe vs tap detection criteria');
            const testCases = [
                { points: 2, duration: 50, keys: 1, distance: 5, expected: 'TAP' },
                { points: 15, duration: 80, keys: 1, distance: 20, expected: 'SWIPE' },
                { points: 5, duration: 200, keys: 1, distance: 15, expected: 'SWIPE' },
                { points: 8, duration: 80, keys: 3, distance: 25, expected: 'SWIPE' },
                { points: 5, duration: 80, keys: 1, distance: 40, expected: 'SWIPE' }
            ];
            
            testCases.forEach((test, i) => {
                const isRealSwipe = (
                    test.points > 10 ||
                    test.duration > 100 ||
                    test.keys > 1 ||
                    (test.points > 3 && test.distance > 30)
                );
                const result = isRealSwipe ? 'SWIPE' : 'TAP';
                const status = result === test.expected ? 'âœ…' : 'âŒ';
                console.log(`Case ${i+1}: ${test.points}pts, ${test.duration}ms, ${test.keys}keys, ${test.distance}px â†’ ${result} ${status}`);
            });
            
            // Test 3: Custom dictionary duplicate prevention
            console.log('\nTest 3: Custom dictionary duplicate prevention');
            if (swipeVocabulary && swipeVocabulary.isLoaded) {
                const commonWords = ['the', 'and', 'for', 'are', 'but', 'not', 'you', 'all'];
                commonWords.forEach(word => {
                    const alreadyExists = swipeVocabulary.hasWord(word);
                    console.log(`"${word}": ${alreadyExists ? 'EXISTS in vocab (would be skipped)' : 'Not in vocab (would be added)'}`);
                });
            } else {
                console.log('âŒ Vocabulary not loaded - cannot test duplicate prevention');
            }
            
            console.log('=== Gesture Detection Test Complete ===');
        }
        
        // Test mobile tap functionality
        function testMobileTapFunctionality() {
            console.log('=== Testing Mobile Tap Functionality ===');
            
            clearInput();
            
            // Test 1: Verify single character tap behavior
            console.log('\nTest 1: Testing single character tap (should NOT show predictions)');
            console.log('Before tap - Predictions:', currentPredictions);
            console.log('Before tap - Input:', document.getElementById('inputText').textContent);
            
            // Directly test single character input
            handleSingleCharacterInput('h');
            
            console.log('After tap - Predictions:', currentPredictions);
            console.log('After tap - Input:', document.getElementById('inputText').textContent);
            console.log('After tap - Has pending predictions:', hasPendingPredictions);
            console.log('Suggestions HTML:', document.getElementById('suggestions').innerHTML);
            
            // Test 2: Test multiple single taps
            console.log('\nTest 2: Testing multiple single taps');
            handleSingleCharacterInput('e');
            handleSingleCharacterInput('l');
            handleSingleCharacterInput('l');
            handleSingleCharacterInput('o');
            
            console.log('After multiple taps:', document.getElementById('inputText').textContent);
            console.log('Should be: "hello" (no spaces, no predictions)');
            
            // Test 3: Test space bar behavior
            console.log('\nTest 3: Testing space bar after single taps');
            handleSingleCharacterInput('space');
            console.log('After space:', document.getElementById('inputText').textContent);
            console.log('Should be: "hello " (one space added)');
            
            // Test 4: Test custom dictionary duplicate prevention
            console.log('\nTest 4: Testing custom dictionary duplicate prevention');
            if (swipeVocabulary && swipeVocabulary.isLoaded && dictionaryManager) {
                const existingWord = 'the';
                console.log(`Testing with existing word: "${existingWord}"`);
                const added = dictionaryManager.addPersonalWord(existingWord);
                console.log(`Add result: ${added ? 'ADDED' : 'SKIPPED (already exists)'} âœ“`);
            }
            
            console.log('=== Mobile Tap Functionality Test Complete ===');
        }
        
        // Test 4th row button isolation
        function testFourthRowButtonIsolation() {
            console.log('=== Testing 4th Row Button Isolation ===');
            
            clearInput();
            
            // Test 1: Verify special buttons are excluded from gesture detection
            console.log('\nTest 1: Special button exclusion test');
            const specialButtons = document.querySelectorAll('[data-special]');
            console.log(`Found ${specialButtons.length} special buttons:`, 
                Array.from(specialButtons).map(b => b.dataset.special));
            
            // Test if getKeyAtPosition ignores special buttons
            const numberButton = document.querySelector('[data-special="number-toggle"]');
            if (numberButton) {
                const rect = numberButton.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const detectedKey = getKeyAtPosition(centerX, centerY);
                console.log(`Number button position test: ${detectedKey ? 'DETECTED AS KEY âŒ' : 'IGNORED âœ…'}`);
            }
            
            // Test 2: Verify functions work
            console.log('\nTest 2: Testing special button functions');
            
            console.log('Before number toggle - Input:', document.getElementById('inputText').textContent);
            toggleNumberMode();
            console.log('After number toggle - Mode:', isNumberMode ? 'NUMBERS âœ“' : 'LETTERS');
            
            console.log('Before space - Input:', document.getElementById('inputText').textContent);
            handleSpace();
            console.log('After space - Input:', JSON.stringify(document.getElementById('inputText').textContent));
            
            console.log('Before return - Input length:', document.getElementById('inputText').textContent.length);
            handleReturn();
            console.log('After return - Input contains newline:', document.getElementById('inputText').textContent.includes('\n') ? 'YES âœ“' : 'NO âŒ');
            
            // Test 3: Reset state
            console.log('\nTest 3: Resetting to normal state');
            if (isNumberMode) toggleNumberMode();
            if (isEmojiMode) toggleEmojiMode();
            clearInput();
            
            console.log('=== 4th Row Button Isolation Test Complete ===');
        }
        
        // Test 4th row functionality
        function testFourthRowFunctionality() {
            console.log('=== Testing 4th Row Functionality ===');
            
            clearInput();
            
            // Test 1: Number mode toggle
            console.log('\nTest 1: Testing number mode');
            console.log('Current keyboard state:', isNumberMode ? 'NUMBERS' : 'LETTERS');
            toggleNumberMode();
            console.log('After toggle:', isNumberMode ? 'NUMBERS' : 'LETTERS');
            
            // Test 2: Number input
            console.log('\nTest 2: Testing number input');
            handleSingleCharacterInput('1');
            handleSingleCharacterInput('2');
            handleSingleCharacterInput('3');
            console.log('After number input:', document.getElementById('inputText').textContent);
            
            // Test 3: Switch back to letters
            console.log('\nTest 3: Switching back to letters');
            toggleNumberMode();
            handleSingleCharacterInput('a');
            handleSingleCharacterInput('b');
            console.log('After letter input:', document.getElementById('inputText').textContent);
            
            // Test 4: Emoji mode
            console.log('\nTest 4: Testing emoji mode');
            toggleEmojiMode();
            console.log('Emoji mode:', isEmojiMode ? 'ON' : 'OFF');
            
            // Test 5: Return functionality
            console.log('\nTest 5: Testing return key');
            handleReturn();
            console.log('After return:', JSON.stringify(document.getElementById('inputText').textContent));
            
            // Test 6: Shift functionality
            console.log('\nTest 6: Testing shift key');
            handleShift();
            const shiftActive = document.querySelector('.key[data-key="shift"]')?.classList.contains('key-active');
            console.log('Shift active:', shiftActive);
            
            console.log('=== 4th Row Functionality Test Complete ===');
            
            // Reset to normal mode
            if (isNumberMode) toggleNumberMode();
            if (isEmojiMode) toggleEmojiMode();
            clearInput();
        }
        
        // Expose test functions globally for debugging
        window.testCustomDictionary = testCustomDictionary;
        window.testTapFunctionality = testTapFunctionality;
        window.testAutoPrediction = testAutoPrediction;
        window.testLongWordSupport = testLongWordSupport;
        window.testSelectionFunctionality = testSelectionFunctionality;
        window.testGestureDetection = testGestureDetection;
        window.testMobileTapFunctionality = testMobileTapFunctionality;
        window.testFourthRowButtonIsolation = testFourthRowButtonIsolation;
        window.testFourthRowFunctionality = testFourthRowFunctionality;
        
        // 4th Row Button Functions
        let isNumberMode = false;
        let isEmojiMode = false;
        
        function toggleNumberMode() {
            isNumberMode = !isNumberMode;
            const button = document.querySelector('button[onclick="toggleNumberMode()"]');
            
            if (isNumberMode) {
                // Change to numbers layout
                updateKeyboardToNumbers();
                button.textContent = 'ABC';
                button.classList.add('bg-neon-blue/20', 'text-neon-blue');
                button.classList.remove('bg-gray-800', 'text-gray-400');
                console.log('ðŸ”¢ Number mode enabled');
            } else {
                // Change back to letters
                updateKeyboardToLetters();
                button.textContent = '123';
                button.classList.remove('bg-neon-blue/20', 'text-neon-blue');
                button.classList.add('bg-gray-800', 'text-gray-400');
                console.log('ðŸ”¤ Letter mode enabled');
            }
        }
        
        function toggleEmojiMode() {
            isEmojiMode = !isEmojiMode;
            const button = document.querySelector('button[onclick="toggleEmojiMode()"]');
            
            if (isEmojiMode) {
                // Show emoji picker or common emojis
                showEmojiKeyboard();
                button.classList.add('bg-neon-purple/20', 'text-neon-purple');
                button.classList.remove('bg-gray-800', 'text-gray-400');
                console.log('ðŸ˜Š Emoji mode enabled');
            } else {
                // Return to normal keyboard
                updateKeyboardToLetters();
                button.classList.remove('bg-neon-purple/20', 'text-neon-purple');
                button.classList.add('bg-gray-800', 'text-gray-400');
                console.log('ðŸ”¤ Letter mode enabled');
            }
        }
        
        function handleReturn() {
            // Add newline to text
            inputText += '\n';
            document.getElementById('inputText').textContent = inputText;
            console.log('ðŸ“ Added newline');
            
            // Clear any pending predictions since we're starting a new line
            clearPredictionState();
        }
        
        // Update keyboard layout to numbers
        function updateKeyboardToNumbers() {
            const numberLayouts = [
                ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
                ['-', '/', ':', ';', '(', ')', '$', '&', '@', '"'],
                ['shift', '.', ',', '?', '!', "'", '"', '+', '*', 'backspace']
            ];
            
            // Update each row
            numberLayouts.forEach((row, rowIndex) => {
                const keys = document.querySelectorAll(`[data-row="${rowIndex}"] .key`);
                row.forEach((char, keyIndex) => {
                    if (keys[keyIndex]) {
                        keys[keyIndex].textContent = char;
                        keys[keyIndex].dataset.key = char;
                        // Update data attributes for numbers
                        if (char.match(/[0-9-/();$&@"'.,?!+*]/)) {
                            keys[keyIndex].dataset.row = rowIndex;
                            keys[keyIndex].dataset.col = keyIndex;
                        }
                    }
                });
            });
        }
        
        // Update keyboard layout to letters  
        function updateKeyboardToLetters() {
            const letterLayouts = [
                ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
                ['shift', 'z', 'x', 'c', 'v', 'b', 'n', 'm', 'backspace']
            ];
            
            // Update each row
            letterLayouts.forEach((row, rowIndex) => {
                const rowDiv = document.querySelector(`[data-row="${rowIndex}"]`)?.parentElement;
                if (rowDiv) {
                    const keys = rowDiv.querySelectorAll('.key');
                    row.forEach((char, keyIndex) => {
                        if (keys[keyIndex]) {
                            keys[keyIndex].textContent = char.toUpperCase();
                            keys[keyIndex].dataset.key = char;
                            keys[keyIndex].dataset.row = rowIndex;
                            keys[keyIndex].dataset.col = keyIndex;
                        }
                    });
                }
            });
        }
        
        // Show emoji keyboard
        function showEmojiKeyboard() {
            const emojiSets = [
                ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ˜‚', 'ðŸ¤£', 'ðŸ˜Š', 'ðŸ˜‡'],
                ['ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Œ', 'ðŸ˜', 'ðŸ¥°', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜™'],
                ['shift', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'backspace']
            ];
            
            // Update each row with emojis
            emojiSets.forEach((row, rowIndex) => {
                const rowDiv = document.querySelector(`[data-row="${rowIndex}"]`)?.parentElement;
                if (rowDiv) {
                    const keys = rowDiv.querySelectorAll('.key');
                    row.forEach((emoji, keyIndex) => {
                        if (keys[keyIndex]) {
                            keys[keyIndex].textContent = emoji;
                            keys[keyIndex].dataset.key = emoji === 'shift' || emoji === 'backspace' ? emoji : emoji;
                        }
                    });
                }
            });
        }
        
        // Setup special button event handling
        function setupSpecialButtonHandlers() {
            // Add event handlers to special buttons to prevent gesture interference
            document.querySelectorAll('[data-special]').forEach(button => {
                // Prevent all gesture events on special buttons
                ['touchstart', 'touchmove', 'touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup'].forEach(eventType => {
                    button.addEventListener(eventType, function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                    }, { passive: false });
                });
                
                // Ensure click events work normally
                button.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // The onclick attribute will still fire
                }, { passive: false });
            });
            
            console.log('âœ“ Special button handlers configured');
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            init();
            setupSpecialButtonHandlers();
        });
    </script>
</body>
</html>